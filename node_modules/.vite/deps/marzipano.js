import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-CF3WPAMV.js";

// node_modules/minimal-event-emitter/index.js
var require_minimal_event_emitter = __commonJS({
  "node_modules/minimal-event-emitter/index.js"(exports, module) {
    "use strict";
    function EventEmitter() {
    }
    EventEmitter.prototype.addEventListener = function(name, fn) {
      var eventMap = this.__events = this.__events || {};
      var handlerList = eventMap[name] = eventMap[name] || [];
      if (handlerList.indexOf(fn) < 0) {
        handlerList.push(fn);
      }
    };
    EventEmitter.prototype.removeEventListener = function(name, fn) {
      var eventMap = this.__events = this.__events || {};
      var handlerList = eventMap[name];
      if (handlerList) {
        var index = handlerList.indexOf(fn);
        if (index >= 0) {
          handlerList.splice(index, 1);
        }
      }
    };
    EventEmitter.prototype.emit = function(name, var_args) {
      var eventMap = this.__events = this.__events || {};
      var handlerList = eventMap[name];
      var args = Array.prototype.slice.call(arguments, 1);
      if (handlerList) {
        for (var i = 0; i < handlerList.length; i++) {
          var fn = handlerList[i];
          fn.apply(this, args);
        }
      }
    };
    function eventEmitter(ctor) {
      for (var prop in EventEmitter.prototype) {
        if (EventEmitter.prototype.hasOwnProperty(prop)) {
          ctor.prototype[prop] = EventEmitter.prototype[prop];
        }
      }
    }
    module.exports = eventEmitter;
  }
});

// node_modules/marzipano/src/util/now.js
var require_now = __commonJS({
  "node_modules/marzipano/src/util/now.js"(exports, module) {
    "use strict";
    function getNow() {
      if (typeof performance !== "undefined" && performance.now) {
        return function performanceNow() {
          return performance.now();
        };
      }
      return function dateNow() {
        return Date.now();
      };
    }
    module.exports = getNow();
  }
});

// node_modules/marzipano/src/collections/WorkQueue.js
var require_WorkQueue = __commonJS({
  "node_modules/marzipano/src/collections/WorkQueue.js"(exports, module) {
    "use strict";
    var now = require_now();
    function WorkTask(fn, cb) {
      this.fn = fn;
      this.cb = cb;
      this.cfn = null;
    }
    function WorkQueue(opts) {
      this._queue = [];
      this._delay = opts && opts.delay || 0;
      this._paused = opts && !!opts.paused || false;
      this._currentTask = null;
      this._lastFinished = null;
    }
    WorkQueue.prototype.length = function() {
      return this._queue.length;
    };
    WorkQueue.prototype.push = function(fn, cb) {
      var task = new WorkTask(fn, cb);
      var cancel = this._cancel.bind(this, task);
      this._queue.push(task);
      this._next();
      return cancel;
    };
    WorkQueue.prototype.pause = function() {
      if (!this._paused) {
        this._paused = true;
      }
    };
    WorkQueue.prototype.resume = function() {
      if (this._paused) {
        this._paused = false;
        this._next();
      }
    };
    WorkQueue.prototype._start = function(task) {
      if (this._currentTask) {
        throw new Error("WorkQueue: called start while running task");
      }
      this._currentTask = task;
      var finish = this._finish.bind(this, task);
      task.cfn = task.fn(finish);
      if (typeof task.cfn !== "function") {
        throw new Error("WorkQueue: function is not cancellable");
      }
    };
    WorkQueue.prototype._finish = function(task) {
      var args = Array.prototype.slice.call(arguments, 1);
      if (this._currentTask !== task) {
        throw new Error("WorkQueue: called finish on wrong task");
      }
      task.cb.apply(null, args);
      this._currentTask = null;
      this._lastFinished = now();
      this._next();
    };
    WorkQueue.prototype._cancel = function(task) {
      var args = Array.prototype.slice.call(arguments, 1);
      if (this._currentTask === task) {
        task.cfn.apply(null, args);
      } else {
        var pos = this._queue.indexOf(task);
        if (pos >= 0) {
          this._queue.splice(pos, 1);
          task.cb.apply(null, args);
        }
      }
    };
    WorkQueue.prototype._next = function() {
      if (this._paused) {
        return;
      }
      if (!this._queue.length) {
        return;
      }
      if (this._currentTask) {
        return;
      }
      if (this._lastFinished != null) {
        var elapsed = now() - this._lastFinished;
        var remaining = this._delay - elapsed;
        if (remaining > 0) {
          setTimeout(this._next.bind(this), remaining);
          return;
        }
      }
      var task = this._queue.shift();
      this._start(task);
    };
    module.exports = WorkQueue;
  }
});

// node_modules/marzipano/src/util/calcRect.js
var require_calcRect = __commonJS({
  "node_modules/marzipano/src/util/calcRect.js"(exports, module) {
    "use strict";
    function calcRect(totalWidth, totalHeight, spec, result) {
      result = result || {};
      var width;
      if (spec != null && spec.absoluteWidth != null) {
        width = spec.absoluteWidth / totalWidth;
      } else if (spec != null && spec.relativeWidth != null) {
        width = spec.relativeWidth;
      } else {
        width = 1;
      }
      var height;
      if (spec && spec.absoluteHeight != null) {
        height = spec.absoluteHeight / totalHeight;
      } else if (spec != null && spec.relativeHeight != null) {
        height = spec.relativeHeight;
      } else {
        height = 1;
      }
      var x;
      if (spec != null && spec.absoluteX != null) {
        x = spec.absoluteX / totalWidth;
      } else if (spec != null && spec.relativeX != null) {
        x = spec.relativeX;
      } else {
        x = 0;
      }
      var y;
      if (spec != null && spec.absoluteY != null) {
        y = spec.absoluteY / totalHeight;
      } else if (spec != null && spec.relativeY != null) {
        y = spec.relativeY;
      } else {
        y = 0;
      }
      result.x = x;
      result.y = y;
      result.width = width;
      result.height = height;
      return result;
    }
    module.exports = calcRect;
  }
});

// node_modules/marzipano/src/util/async.js
var require_async = __commonJS({
  "node_modules/marzipano/src/util/async.js"(exports, module) {
    "use strict";
    function async(fn) {
      return function asynced(done) {
        var err, ret;
        try {
          ret = fn();
        } catch (e) {
          err = e;
        } finally {
          if (err) {
            done(err);
          } else {
            done(null, ret);
          }
        }
      };
    }
    module.exports = async;
  }
});

// node_modules/marzipano/src/util/once.js
var require_once = __commonJS({
  "node_modules/marzipano/src/util/once.js"(exports, module) {
    "use strict";
    function once(fn) {
      var called = false;
      var value;
      return function onced() {
        if (!called) {
          called = true;
          value = fn.apply(null, arguments);
        }
        return value;
      };
    }
    module.exports = once;
  }
});

// node_modules/marzipano/src/util/cancelize.js
var require_cancelize = __commonJS({
  "node_modules/marzipano/src/util/cancelize.js"(exports, module) {
    "use strict";
    var once = require_once();
    function cancelize(fn) {
      return function cancelized() {
        if (!arguments.length) {
          throw new Error("cancelized: expected at least one argument");
        }
        var args = Array.prototype.slice.call(arguments, 0);
        var done = args[args.length - 1] = once(args[args.length - 1]);
        function cancel() {
          done.apply(null, arguments);
        }
        fn.apply(null, args);
        return cancel;
      };
    }
    module.exports = cancelize;
  }
});

// node_modules/marzipano/src/util/clearOwnProperties.js
var require_clearOwnProperties = __commonJS({
  "node_modules/marzipano/src/util/clearOwnProperties.js"(exports, module) {
    "use strict";
    function clearOwnProperties(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          obj[prop] = void 0;
        }
      }
    }
    module.exports = clearOwnProperties;
  }
});

// node_modules/marzipano/src/stages/RendererRegistry.js
var require_RendererRegistry = __commonJS({
  "node_modules/marzipano/src/stages/RendererRegistry.js"(exports, module) {
    "use strict";
    function RendererRegistry() {
      this._renderers = {};
    }
    RendererRegistry.prototype.set = function(geometryType, viewType, Renderer) {
      if (!this._renderers[geometryType]) {
        this._renderers[geometryType] = {};
      }
      this._renderers[geometryType][viewType] = Renderer;
    };
    RendererRegistry.prototype.get = function(geometryType, viewType) {
      var Renderer = this._renderers[geometryType] && this._renderers[geometryType][viewType];
      return Renderer || null;
    };
    module.exports = RendererRegistry;
  }
});

// node_modules/marzipano/src/stages/Stage.js
var require_Stage = __commonJS({
  "node_modules/marzipano/src/stages/Stage.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var WorkQueue = require_WorkQueue();
    var calcRect = require_calcRect();
    var async = require_async();
    var cancelize = require_cancelize();
    var clearOwnProperties = require_clearOwnProperties();
    var RendererRegistry = require_RendererRegistry();
    function forwardTileCmp(t1, t2) {
      return t1.cmp(t2);
    }
    function reverseTileCmp(t1, t2) {
      return -t1.cmp(t2);
    }
    function Stage(opts) {
      this._progressive = !!(opts && opts.progressive);
      this._layers = [];
      this._renderers = [];
      this._tilesToLoad = [];
      this._tilesToRender = [];
      this._tmpVisible = [];
      this._tmpChildren = [];
      this._width = 0;
      this._height = 0;
      this._tmpRect = {};
      this._tmpSize = {};
      this._createTextureWorkQueue = new WorkQueue();
      this._emitRenderInvalid = this._emitRenderInvalid.bind(this);
      this._rendererRegistry = new RendererRegistry();
    }
    eventEmitter(Stage);
    Stage.prototype.destroy = function() {
      this.removeAllLayers();
      clearOwnProperties(this);
    };
    Stage.prototype.registerRenderer = function(geometryType, viewType, Renderer) {
      return this._rendererRegistry.set(geometryType, viewType, Renderer);
    };
    Stage.prototype.domElement = function() {
      throw new Error("Stage implementation must override domElement");
    };
    Stage.prototype.width = function() {
      return this._width;
    };
    Stage.prototype.height = function() {
      return this._height;
    };
    Stage.prototype.size = function(size) {
      size = size || {};
      size.width = this._width;
      size.height = this._height;
      return size;
    };
    Stage.prototype.setSize = function(size) {
      this._width = size.width;
      this._height = size.height;
      this.setSizeForType();
      this.emit("resize");
      this._emitRenderInvalid();
    };
    Stage.prototype.setSizeForType = function(size) {
      throw new Error("Stage implementation must override setSizeForType");
    };
    Stage.prototype.loadImage = function() {
      throw new Error("Stage implementation must override loadImage");
    };
    Stage.prototype._emitRenderInvalid = function() {
      this.emit("renderInvalid");
    };
    Stage.prototype.validateLayer = function(layer) {
      throw new Error("Stage implementation must override validateLayer");
    };
    Stage.prototype.listLayers = function() {
      return [].concat(this._layers);
    };
    Stage.prototype.hasLayer = function(layer) {
      return this._layers.indexOf(layer) >= 0;
    };
    Stage.prototype.addLayer = function(layer, i) {
      if (this._layers.indexOf(layer) >= 0) {
        throw new Error("Layer already in stage");
      }
      if (i == null) {
        i = this._layers.length;
      }
      if (i < 0 || i > this._layers.length) {
        throw new Error("Invalid layer position");
      }
      this.validateLayer(layer);
      var geometryType = layer.geometry().type;
      var viewType = layer.view().type;
      var rendererClass = this._rendererRegistry.get(geometryType, viewType);
      if (!rendererClass) {
        throw new Error("No " + this.type + " renderer avaiable for " + geometryType + " geometry and " + viewType + " view");
      }
      var renderer = this.createRenderer(rendererClass);
      this._layers.splice(i, 0, layer);
      this._renderers.splice(i, 0, renderer);
      layer.addEventListener("viewChange", this._emitRenderInvalid);
      layer.addEventListener("effectsChange", this._emitRenderInvalid);
      layer.addEventListener("fixedLevelChange", this._emitRenderInvalid);
      layer.addEventListener("textureStoreChange", this._emitRenderInvalid);
      this._emitRenderInvalid();
    };
    Stage.prototype.moveLayer = function(layer, i) {
      var index = this._layers.indexOf(layer);
      if (index < 0) {
        throw new Error("No such layer in stage");
      }
      if (i < 0 || i >= this._layers.length) {
        throw new Error("Invalid layer position");
      }
      layer = this._layers.splice(index, 1)[0];
      var renderer = this._renderers.splice(index, 1)[0];
      this._layers.splice(i, 0, layer);
      this._renderers.splice(i, 0, renderer);
      this._emitRenderInvalid();
    };
    Stage.prototype.removeLayer = function(layer) {
      var index = this._layers.indexOf(layer);
      if (index < 0) {
        throw new Error("No such layer in stage");
      }
      var removedLayer = this._layers.splice(index, 1)[0];
      var renderer = this._renderers.splice(index, 1)[0];
      this.destroyRenderer(renderer);
      removedLayer.removeEventListener("viewChange", this._emitRenderInvalid);
      removedLayer.removeEventListener("effectsChange", this._emitRenderInvalid);
      removedLayer.removeEventListener("fixedLevelChange", this._emitRenderInvalid);
      removedLayer.removeEventListener("textureStoreChange", this._emitRenderInvalid);
      this._emitRenderInvalid();
    };
    Stage.prototype.removeAllLayers = function() {
      while (this._layers.length > 0) {
        this.removeLayer(this._layers[0]);
      }
    };
    Stage.prototype.startFrame = function() {
      throw new Error("Stage implementation must override startFrame");
    };
    Stage.prototype.endFrame = function() {
      throw new Error("Stage implementation must override endFrame");
    };
    Stage.prototype.render = function() {
      var i, j;
      var tilesToLoad = this._tilesToLoad;
      var tilesToRender = this._tilesToRender;
      var stableStage = true;
      var stableLayer;
      var width = this._width;
      var height = this._height;
      var rect = this._tmpRect;
      var size = this._tmpSize;
      if (width <= 0 || height <= 0) {
        return;
      }
      this.startFrame();
      for (i = 0; i < this._layers.length; i++) {
        this._layers[i].textureStore().startFrame();
      }
      for (i = 0; i < this._layers.length; i++) {
        var layer = this._layers[i];
        var effects = layer.effects();
        var view = layer.view();
        var textureStore = layer.textureStore();
        var renderer = this._renderers[i];
        var depth = this._layers.length - i;
        var tile2, texture;
        calcRect(width, height, effects && effects.rect, rect);
        if (rect.width <= 0 || rect.height <= 0) {
          continue;
        }
        size.width = rect.width * this._width;
        size.height = rect.height * this._height;
        view.setSize(size);
        renderer.startLayer(layer, rect);
        stableLayer = this._collectTiles(layer, textureStore);
        for (j = 0; j < tilesToLoad.length; j++) {
          tile2 = tilesToLoad[j];
          textureStore.markTile(tile2);
        }
        for (j = 0; j < tilesToRender.length; j++) {
          tile2 = tilesToRender[j];
          texture = textureStore.texture(tile2);
          renderer.renderTile(tile2, texture, layer, depth);
        }
        layer.emit("renderComplete", stableLayer);
        if (!stableLayer) {
          stableStage = false;
        }
        renderer.endLayer(layer, rect);
      }
      for (i = 0; i < this._layers.length; i++) {
        this._layers[i].textureStore().endFrame();
      }
      this.endFrame();
      this.emit("renderComplete", stableStage);
    };
    Stage.prototype._collectTiles = function(layer, textureStore) {
      var tilesToLoad = this._tilesToLoad;
      var tilesToRender = this._tilesToRender;
      var tmpVisible = this._tmpVisible;
      tilesToLoad.length = 0;
      tilesToRender.length = 0;
      tmpVisible.length = 0;
      layer.visibleTiles(tmpVisible);
      var isStable = true;
      for (var i = 0; i < tmpVisible.length; i++) {
        var tile2 = tmpVisible[i];
        var needsFallback;
        this._collectTileToLoad(tile2);
        if (textureStore.texture(tile2)) {
          needsFallback = false;
          this._collectTileToRender(tile2);
        } else {
          needsFallback = this._collectChildren(tile2, textureStore);
          isStable = false;
        }
        this._collectParents(tile2, textureStore, needsFallback);
      }
      tilesToLoad.sort(forwardTileCmp);
      tilesToRender.sort(reverseTileCmp);
      return isStable;
    };
    Stage.prototype._collectChildren = function(tile2, textureStore) {
      var tmpChildren = this._tmpChildren;
      var needsFallback = true;
      do {
        tmpChildren.length = 0;
        if (!tile2.children(tmpChildren)) {
          break;
        }
        needsFallback = false;
        for (var i = 0; i < tmpChildren.length; i++) {
          tile2 = tmpChildren[i];
          if (textureStore.texture(tile2)) {
            this._collectTileToLoad(tile2);
            this._collectTileToRender(tile2);
          } else {
            needsFallback = true;
          }
        }
      } while (needsFallback && tmpChildren.length === 1);
      return needsFallback;
    };
    Stage.prototype._collectParents = function(tile2, textureStore, needsFallback) {
      var needsLoading = this._progressive;
      while ((needsLoading || needsFallback) && (tile2 = tile2.parent()) != null) {
        if (needsFallback) {
          if (textureStore.texture(tile2)) {
            this._collectTileToRender(tile2);
            needsFallback = false;
          } else if (!this._progressive) {
            continue;
          }
        }
        if (!this._collectTileToLoad(tile2)) {
          needsLoading = false;
        }
      }
      return needsFallback;
    };
    Stage.prototype._collectTileToLoad = function(tile2) {
      return this._collectTileIntoList(tile2, this._tilesToLoad);
    };
    Stage.prototype._collectTileToRender = function(tile2) {
      return this._collectTileIntoList(tile2, this._tilesToRender);
    };
    Stage.prototype._collectTileIntoList = function(tile2, tileList) {
      var found = false;
      for (var i = 0; i < tileList.length; i++) {
        if (tile2.equals(tileList[i])) {
          found = true;
          break;
        }
      }
      if (!found) {
        tileList.push(tile2);
      }
      return !found;
    };
    Stage.prototype.createTexture = function(tile2, asset, done) {
      var self2 = this;
      function makeTexture() {
        return new self2.TextureClass(self2, tile2, asset);
      }
      var fn = cancelize(async(makeTexture));
      return this._createTextureWorkQueue.push(fn, function(err, texture) {
        done(err, tile2, asset, texture);
      });
    };
    module.exports = Stage;
  }
});

// node_modules/marzipano/src/util/global.js
var require_global = __commonJS({
  "node_modules/marzipano/src/util/global.js"(exports, module) {
    "use strict";
    var globalObject = function() {
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      return null;
    }();
    module.exports = globalObject;
  }
});

// node_modules/marzipano/src/assets/Static.js
var require_Static = __commonJS({
  "node_modules/marzipano/src/assets/Static.js"(exports, module) {
    "use strict";
    var global2 = require_global();
    var eventEmitter = require_minimal_event_emitter();
    var clearOwnProperties = require_clearOwnProperties();
    var propertyMap = {
      HTMLImageElement: ["naturalWidth", "naturalHeight"],
      HTMLCanvasElement: ["width", "height"],
      ImageBitmap: ["width", "height"]
    };
    function StaticAsset(element) {
      var supported = false;
      for (var type in propertyMap) {
        if (global2[type] && element instanceof global2[type]) {
          supported = true;
          this._widthProp = propertyMap[type][0];
          this._heightProp = propertyMap[type][1];
          break;
        }
      }
      if (!supported) {
        throw new Error("Unsupported pixel source");
      }
      this._element = element;
    }
    eventEmitter(StaticAsset);
    StaticAsset.prototype.destroy = function() {
      clearOwnProperties(this);
    };
    StaticAsset.prototype.element = function() {
      return this._element;
    };
    StaticAsset.prototype.width = function() {
      return this._element[this._widthProp];
    };
    StaticAsset.prototype.height = function() {
      return this._element[this._heightProp];
    };
    StaticAsset.prototype.timestamp = function() {
      return 0;
    };
    StaticAsset.prototype.isDynamic = function() {
      return false;
    };
    module.exports = StaticAsset;
  }
});

// node_modules/marzipano/src/util/inherits.js
var require_inherits = __commonJS({
  "node_modules/marzipano/src/util/inherits.js"(exports, module) {
    "use strict";
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    module.exports = inherits;
  }
});

// node_modules/marzipano/src/NetworkError.js
var require_NetworkError = __commonJS({
  "node_modules/marzipano/src/NetworkError.js"(exports, module) {
    "use strict";
    var inherits = require_inherits();
    function NetworkError(message) {
      this.constructor.super_.apply(this, arguments);
      this.message = message;
    }
    inherits(NetworkError, Error);
    module.exports = NetworkError;
  }
});

// node_modules/bowser/src/bowser.js
var require_bowser = __commonJS({
  "node_modules/bowser/src/bowser.js"(exports, module) {
    !function(root, name, definition) {
      if (typeof module != "undefined" && module.exports)
        module.exports = definition();
      else if (typeof define == "function" && define.amd)
        define(name, definition);
      else
        root[name] = definition();
    }(exports, "bowser", function() {
      var t = true;
      function detect(ua) {
        function getFirstMatch(regex) {
          var match = ua.match(regex);
          return match && match.length > 1 && match[1] || "";
        }
        function getSecondMatch(regex) {
          var match = ua.match(regex);
          return match && match.length > 1 && match[2] || "";
        }
        var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(), likeAndroid = /like android/i.test(ua), android = !likeAndroid && /android/i.test(ua), nexusMobile = /nexus\s*[0-6]\s*/i.test(ua), nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua), chromeos = /CrOS/.test(ua), silk = /silk/i.test(ua), sailfish = /sailfish/i.test(ua), tizen = /tizen/i.test(ua), webos = /(web|hpw)(o|0)s/i.test(ua), windowsphone = /windows phone/i.test(ua), samsungBrowser = /SamsungBrowser/i.test(ua), windows = !windowsphone && /windows/i.test(ua), mac = !iosdevice && !silk && /macintosh/i.test(ua), linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua), edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i), tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua), mobile = !tablet && /[^-]mobi/i.test(ua), xbox = /xbox/i.test(ua), result;
        if (/opera/i.test(ua)) {
          result = {
            name: "Opera",
            opera: t,
            version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
          };
        } else if (/opr\/|opios/i.test(ua)) {
          result = {
            name: "Opera",
            opera: t,
            version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
          };
        } else if (/SamsungBrowser/i.test(ua)) {
          result = {
            name: "Samsung Internet for Android",
            samsungBrowser: t,
            version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
          };
        } else if (/Whale/i.test(ua)) {
          result = {
            name: "NAVER Whale browser",
            whale: t,
            version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/MZBrowser/i.test(ua)) {
          result = {
            name: "MZ Browser",
            mzbrowser: t,
            version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/coast/i.test(ua)) {
          result = {
            name: "Opera Coast",
            coast: t,
            version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
          };
        } else if (/focus/i.test(ua)) {
          result = {
            name: "Focus",
            focus: t,
            version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/yabrowser/i.test(ua)) {
          result = {
            name: "Yandex Browser",
            yandexbrowser: t,
            version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
          };
        } else if (/ucbrowser/i.test(ua)) {
          result = {
            name: "UC Browser",
            ucbrowser: t,
            version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/mxios/i.test(ua)) {
          result = {
            name: "Maxthon",
            maxthon: t,
            version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/epiphany/i.test(ua)) {
          result = {
            name: "Epiphany",
            epiphany: t,
            version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/puffin/i.test(ua)) {
          result = {
            name: "Puffin",
            puffin: t,
            version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
          };
        } else if (/sleipnir/i.test(ua)) {
          result = {
            name: "Sleipnir",
            sleipnir: t,
            version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (/k-meleon/i.test(ua)) {
          result = {
            name: "K-Meleon",
            kMeleon: t,
            version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
          };
        } else if (windowsphone) {
          result = {
            name: "Windows Phone",
            osname: "Windows Phone",
            windowsphone: t
          };
          if (edgeVersion) {
            result.msedge = t;
            result.version = edgeVersion;
          } else {
            result.msie = t;
            result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
          }
        } else if (/msie|trident/i.test(ua)) {
          result = {
            name: "Internet Explorer",
            msie: t,
            version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
          };
        } else if (chromeos) {
          result = {
            name: "Chrome",
            osname: "Chrome OS",
            chromeos: t,
            chromeBook: t,
            chrome: t,
            version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
          };
        } else if (/edg([ea]|ios)/i.test(ua)) {
          result = {
            name: "Microsoft Edge",
            msedge: t,
            version: edgeVersion
          };
        } else if (/vivaldi/i.test(ua)) {
          result = {
            name: "Vivaldi",
            vivaldi: t,
            version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
          };
        } else if (sailfish) {
          result = {
            name: "Sailfish",
            osname: "Sailfish OS",
            sailfish: t,
            version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
          };
        } else if (/seamonkey\//i.test(ua)) {
          result = {
            name: "SeaMonkey",
            seamonkey: t,
            version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
          };
        } else if (/firefox|iceweasel|fxios/i.test(ua)) {
          result = {
            name: "Firefox",
            firefox: t,
            version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
          };
          if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
            result.firefoxos = t;
            result.osname = "Firefox OS";
          }
        } else if (silk) {
          result = {
            name: "Amazon Silk",
            silk: t,
            version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
          };
        } else if (/phantom/i.test(ua)) {
          result = {
            name: "PhantomJS",
            phantom: t,
            version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
          };
        } else if (/slimerjs/i.test(ua)) {
          result = {
            name: "SlimerJS",
            slimer: t,
            version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
          };
        } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
          result = {
            name: "BlackBerry",
            osname: "BlackBerry OS",
            blackberry: t,
            version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
          };
        } else if (webos) {
          result = {
            name: "WebOS",
            osname: "WebOS",
            webos: t,
            version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
          };
          /touchpad\//i.test(ua) && (result.touchpad = t);
        } else if (/bada/i.test(ua)) {
          result = {
            name: "Bada",
            osname: "Bada",
            bada: t,
            version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
          };
        } else if (tizen) {
          result = {
            name: "Tizen",
            osname: "Tizen",
            tizen: t,
            version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
          };
        } else if (/qupzilla/i.test(ua)) {
          result = {
            name: "QupZilla",
            qupzilla: t,
            version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
          };
        } else if (/chromium/i.test(ua)) {
          result = {
            name: "Chromium",
            chromium: t,
            version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
          };
        } else if (/chrome|crios|crmo/i.test(ua)) {
          result = {
            name: "Chrome",
            chrome: t,
            version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
          };
        } else if (android) {
          result = {
            name: "Android",
            version: versionIdentifier
          };
        } else if (/safari|applewebkit/i.test(ua)) {
          result = {
            name: "Safari",
            safari: t
          };
          if (versionIdentifier) {
            result.version = versionIdentifier;
          }
        } else if (iosdevice) {
          result = {
            name: iosdevice == "iphone" ? "iPhone" : iosdevice == "ipad" ? "iPad" : "iPod"
          };
          if (versionIdentifier) {
            result.version = versionIdentifier;
          }
        } else if (/googlebot/i.test(ua)) {
          result = {
            name: "Googlebot",
            googlebot: t,
            version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
          };
        } else {
          result = {
            name: getFirstMatch(/^(.*)\/(.*) /),
            version: getSecondMatch(/^(.*)\/(.*) /)
          };
        }
        if (!result.msedge && /(apple)?webkit/i.test(ua)) {
          if (/(apple)?webkit\/537\.36/i.test(ua)) {
            result.name = result.name || "Blink";
            result.blink = t;
          } else {
            result.name = result.name || "Webkit";
            result.webkit = t;
          }
          if (!result.version && versionIdentifier) {
            result.version = versionIdentifier;
          }
        } else if (!result.opera && /gecko\//i.test(ua)) {
          result.name = result.name || "Gecko";
          result.gecko = t;
          result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
        }
        if (!result.windowsphone && (android || result.silk)) {
          result.android = t;
          result.osname = "Android";
        } else if (!result.windowsphone && iosdevice) {
          result[iosdevice] = t;
          result.ios = t;
          result.osname = "iOS";
        } else if (mac) {
          result.mac = t;
          result.osname = "macOS";
        } else if (xbox) {
          result.xbox = t;
          result.osname = "Xbox";
        } else if (windows) {
          result.windows = t;
          result.osname = "Windows";
        } else if (linux) {
          result.linux = t;
          result.osname = "Linux";
        }
        function getWindowsVersion(s) {
          switch (s) {
            case "NT":
              return "NT";
            case "XP":
              return "XP";
            case "NT 5.0":
              return "2000";
            case "NT 5.1":
              return "XP";
            case "NT 5.2":
              return "2003";
            case "NT 6.0":
              return "Vista";
            case "NT 6.1":
              return "7";
            case "NT 6.2":
              return "8";
            case "NT 6.3":
              return "8.1";
            case "NT 10.0":
              return "10";
            default:
              return void 0;
          }
        }
        var osVersion = "";
        if (result.windows) {
          osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i));
        } else if (result.windowsphone) {
          osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
        } else if (result.mac) {
          osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
          osVersion = osVersion.replace(/[_\s]/g, ".");
        } else if (iosdevice) {
          osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
          osVersion = osVersion.replace(/[_\s]/g, ".");
        } else if (android) {
          osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
        } else if (result.webos) {
          osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
        } else if (result.blackberry) {
          osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
        } else if (result.bada) {
          osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
        } else if (result.tizen) {
          osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
        }
        if (osVersion) {
          result.osversion = osVersion;
        }
        var osMajorVersion = !result.windows && osVersion.split(".")[0];
        if (tablet || nexusTablet || iosdevice == "ipad" || android && (osMajorVersion == 3 || osMajorVersion >= 4 && !mobile) || result.silk) {
          result.tablet = t;
        } else if (mobile || iosdevice == "iphone" || iosdevice == "ipod" || android || nexusMobile || result.blackberry || result.webos || result.bada) {
          result.mobile = t;
        }
        if (result.msedge || result.msie && result.version >= 10 || result.yandexbrowser && result.version >= 15 || result.vivaldi && result.version >= 1 || result.chrome && result.version >= 20 || result.samsungBrowser && result.version >= 4 || result.whale && compareVersions([result.version, "1.0"]) === 1 || result.mzbrowser && compareVersions([result.version, "6.0"]) === 1 || result.focus && compareVersions([result.version, "1.0"]) === 1 || result.firefox && result.version >= 20 || result.safari && result.version >= 6 || result.opera && result.version >= 10 || result.ios && result.osversion && result.osversion.split(".")[0] >= 6 || result.blackberry && result.version >= 10.1 || result.chromium && result.version >= 20) {
          result.a = t;
        } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20 || result.safari && result.version < 6 || result.opera && result.version < 10 || result.ios && result.osversion && result.osversion.split(".")[0] < 6 || result.chromium && result.version < 20) {
          result.c = t;
        } else
          result.x = t;
        return result;
      }
      var bowser = detect(typeof navigator !== "undefined" ? navigator.userAgent || "" : "");
      bowser.test = function(browserList) {
        for (var i = 0; i < browserList.length; ++i) {
          var browserItem = browserList[i];
          if (typeof browserItem === "string") {
            if (browserItem in bowser) {
              return true;
            }
          }
        }
        return false;
      };
      function getVersionPrecision(version) {
        return version.split(".").length;
      }
      function map(arr, iterator) {
        var result = [], i;
        if (Array.prototype.map) {
          return Array.prototype.map.call(arr, iterator);
        }
        for (i = 0; i < arr.length; i++) {
          result.push(iterator(arr[i]));
        }
        return result;
      }
      function compareVersions(versions) {
        var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
        var chunks = map(versions, function(version) {
          var delta = precision - getVersionPrecision(version);
          version = version + new Array(delta + 1).join(".0");
          return map(version.split("."), function(chunk) {
            return new Array(20 - chunk.length).join("0") + chunk;
          }).reverse();
        });
        while (--precision >= 0) {
          if (chunks[0][precision] > chunks[1][precision]) {
            return 1;
          } else if (chunks[0][precision] === chunks[1][precision]) {
            if (precision === 0) {
              return 0;
            }
          } else {
            return -1;
          }
        }
      }
      function isUnsupportedBrowser(minVersions, strictMode, ua) {
        var _bowser = bowser;
        if (typeof strictMode === "string") {
          ua = strictMode;
          strictMode = void 0;
        }
        if (strictMode === void 0) {
          strictMode = false;
        }
        if (ua) {
          _bowser = detect(ua);
        }
        var version = "" + _bowser.version;
        for (var browser in minVersions) {
          if (minVersions.hasOwnProperty(browser)) {
            if (_bowser[browser]) {
              if (typeof minVersions[browser] !== "string") {
                throw new Error("Browser version in the minVersion map should be a string: " + browser + ": " + String(minVersions));
              }
              return compareVersions([version, minVersions[browser]]) < 0;
            }
          }
        }
        return strictMode;
      }
      function check(minVersions, strictMode, ua) {
        return !isUnsupportedBrowser(minVersions, strictMode, ua);
      }
      bowser.isUnsupportedBrowser = isUnsupportedBrowser;
      bowser.compareVersions = compareVersions;
      bowser.check = check;
      bowser._detect = detect;
      bowser.detect = detect;
      return bowser;
    });
  }
});

// node_modules/marzipano/src/loaders/HtmlImage.js
var require_HtmlImage = __commonJS({
  "node_modules/marzipano/src/loaders/HtmlImage.js"(exports, module) {
    "use strict";
    var StaticAsset = require_Static();
    var NetworkError = require_NetworkError();
    var browser = require_bowser();
    var global2 = require_global();
    var once = require_once();
    var useCreateImageBitmap = !!global2.createImageBitmap && !browser.firefox;
    var createImageBitmapOpts = {
      imageOrientation: "flipY",
      premultiplyAlpha: "premultiply"
    };
    function HtmlImageLoader(stage) {
      this._stage = stage;
    }
    HtmlImageLoader.prototype.loadImage = function(url, rect, done) {
      var self2 = this;
      var img = new Image();
      img.crossOrigin = "anonymous";
      var x = rect && rect.x || 0;
      var y = rect && rect.y || 0;
      var width = rect && rect.width || 1;
      var height = rect && rect.height || 1;
      done = once(done);
      img.onload = function() {
        self2._handleLoad(img, x, y, width, height, done);
      };
      img.onerror = function() {
        self2._handleError(url, done);
      };
      img.src = url;
      function cancel() {
        img.onload = img.onerror = null;
        img.src = "";
        done.apply(null, arguments);
      }
      return cancel;
    };
    HtmlImageLoader.prototype._handleLoad = function(img, x, y, width, height, done) {
      if (x === 0 && y === 0 && width === 1 && height === 1) {
        done(null, new StaticAsset(img));
        return;
      }
      x *= img.naturalWidth;
      y *= img.naturalHeight;
      width *= img.naturalWidth;
      height *= img.naturalHeight;
      if (useCreateImageBitmap) {
        global2.createImageBitmap(img, x, y, width, height, createImageBitmapOpts).then(function(bitmap) {
          done(null, new StaticAsset(bitmap));
        });
      } else {
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext("2d");
        context.drawImage(img, x, y, width, height, 0, 0, width, height);
        done(null, new StaticAsset(canvas));
      }
    };
    HtmlImageLoader.prototype._handleError = function(url, done) {
      done(new NetworkError("Network error: " + url));
    };
    module.exports = HtmlImageLoader;
  }
});

// node_modules/marzipano/src/util/pixelRatio.js
var require_pixelRatio = __commonJS({
  "node_modules/marzipano/src/util/pixelRatio.js"(exports, module) {
    "use strict";
    var defaultPixelRatio = 1;
    function pixelRatio() {
      if (typeof window !== "undefined") {
        if (window.devicePixelRatio) {
          return window.devicePixelRatio;
        } else {
          var screen = window.screen;
          if (screen && screen.deviceXDPI && screen.logicalXDPI) {
            return screen.deviceXDPI / screen.logicalXDPI;
          } else if (screen && screen.systemXDPI && screen.logicalXDPI) {
            return screen.systemXDPI / screen.logicalXDPI;
          }
        }
      }
      return defaultPixelRatio;
    }
    module.exports = pixelRatio;
  }
});

// node_modules/marzipano/src/util/ispot.js
var require_ispot = __commonJS({
  "node_modules/marzipano/src/util/ispot.js"(exports, module) {
    "use strict";
    function ispot(n) {
      return (n & n - 1) == 0;
    }
    module.exports = ispot;
  }
});

// node_modules/marzipano/src/util/dom.js
var require_dom = __commonJS({
  "node_modules/marzipano/src/util/dom.js"(exports, module) {
    "use strict";
    function prefixProperty(property) {
      var style = document.documentElement.style;
      var prefixList = ["Moz", "Webkit", "Khtml", "O", "ms"];
      for (var i = 0; i < prefixList.length; i++) {
        var prefix = prefixList[i];
        var capitalizedProperty = property[0].toUpperCase() + property.slice(1);
        var prefixedProperty = prefix + capitalizedProperty;
        if (prefixedProperty in style) {
          return prefixedProperty;
        }
      }
      return property;
    }
    function getWithVendorPrefix(property) {
      var prefixedProperty = prefixProperty(property);
      return function getPropertyWithVendorPrefix(element) {
        return element.style[prefixedProperty];
      };
    }
    function setWithVendorPrefix(property) {
      var prefixedProperty = prefixProperty(property);
      return function setPropertyWithVendorPrefix(element, val) {
        return element.style[prefixedProperty] = val;
      };
    }
    var setTransform = setWithVendorPrefix("transform");
    var setTransformOrigin = setWithVendorPrefix("transformOrigin");
    function setNullTransform(element) {
      setTransform(element, "translateZ(0)");
    }
    function setNullTransformOrigin(element) {
      setTransformOrigin(element, "0 0 0");
    }
    function setAbsolute(element) {
      element.style.position = "absolute";
    }
    function setPixelPosition(element, x, y) {
      element.style.left = x + "px";
      element.style.top = y + "px";
    }
    function setPixelSize(element, width, height) {
      element.style.width = width + "px";
      element.style.height = height + "px";
    }
    function setNullSize(element) {
      element.style.width = element.style.height = 0;
    }
    function setFullSize(element) {
      element.style.width = element.style.height = "100%";
    }
    function setOverflowHidden(element) {
      element.style.overflow = "hidden";
    }
    function setOverflowVisible(element) {
      element.style.overflow = "visible";
    }
    function setNoPointerEvents(element) {
      element.style.pointerEvents = "none";
    }
    module.exports = {
      prefixProperty,
      getWithVendorPrefix,
      setWithVendorPrefix,
      setTransform,
      setTransformOrigin,
      setNullTransform,
      setNullTransformOrigin,
      setAbsolute,
      setPixelPosition,
      setPixelSize,
      setNullSize,
      setFullSize,
      setOverflowHidden,
      setOverflowVisible,
      setNoPointerEvents
    };
  }
});

// node_modules/marzipano/src/stages/WebGl.js
var require_WebGl = __commonJS({
  "node_modules/marzipano/src/stages/WebGl.js"(exports, module) {
    "use strict";
    var Stage = require_Stage();
    var HtmlImageLoader = require_HtmlImage();
    var browser = require_bowser();
    var inherits = require_inherits();
    var pixelRatio = require_pixelRatio();
    var ispot = require_ispot();
    var setAbsolute = require_dom().setAbsolute;
    var setFullSize = require_dom().setFullSize;
    var clearOwnProperties = require_clearOwnProperties();
    var browserQuirks = {
      // Whether to use texImage2D instead of texSubImage2D when repainting an
      // existing texture from a video element. On most browsers texSubImage2D is
      // faster, but on Chrome the performance degrades significantly. See:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=612542
      videoUseTexImage2D: browser.chrome
    };
    function initWebGlContext(canvas, opts) {
      var options = {
        alpha: true,
        premultipliedAlpha: true,
        antialias: !!(opts && opts.antialias),
        preserveDrawingBuffer: !!(opts && opts.preserveDrawingBuffer)
      };
      var gl = canvas.getContext && (canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options));
      if (!gl) {
        throw new Error("Could not get WebGL context");
      }
      if (opts.wrapContext) {
        gl = opts.wrapContext(gl);
      }
      return gl;
    }
    function WebGlStage(opts) {
      opts = opts || {};
      var self2 = this;
      this.constructor.super_.call(this, opts);
      this._generateMipmaps = opts.generateMipmaps != null ? opts.generateMipmaps : false;
      this._loader = new HtmlImageLoader(this);
      this._domElement = document.createElement("canvas");
      setAbsolute(this._domElement);
      setFullSize(this._domElement);
      this._gl = initWebGlContext(this._domElement, opts);
      this._handleContextLoss = function() {
        self2.emit("webglcontextlost");
        self2._gl = null;
      };
      this._domElement.addEventListener("webglcontextlost", this._handleContextLoss);
      this._rendererInstances = [];
    }
    inherits(WebGlStage, Stage);
    WebGlStage.prototype.destroy = function() {
      this._domElement.removeEventListener("webglcontextlost", this._handleContextLoss);
      this.constructor.super_.prototype.destroy.call(this);
    };
    WebGlStage.prototype.domElement = function() {
      return this._domElement;
    };
    WebGlStage.prototype.webGlContext = function() {
      return this._gl;
    };
    WebGlStage.prototype.setSizeForType = function() {
      var ratio = pixelRatio();
      this._domElement.width = ratio * this._width;
      this._domElement.height = ratio * this._height;
    };
    WebGlStage.prototype.loadImage = function(url, rect, done) {
      return this._loader.loadImage(url, rect, done);
    };
    WebGlStage.prototype.maxTextureSize = function() {
      return this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);
    };
    WebGlStage.prototype.validateLayer = function(layer) {
      var tileSize = layer.geometry().maxTileSize();
      var maxTextureSize = this.maxTextureSize();
      if (tileSize > maxTextureSize) {
        throw new Error("Layer has level with tile size larger than maximum texture size (" + tileSize + " vs. " + maxTextureSize + ")");
      }
    };
    WebGlStage.prototype.createRenderer = function(Renderer) {
      var rendererInstances = this._rendererInstances;
      for (var i = 0; i < rendererInstances.length; i++) {
        if (rendererInstances[i] instanceof Renderer) {
          return rendererInstances[i];
        }
      }
      var renderer = new Renderer(this._gl);
      rendererInstances.push(renderer);
      return renderer;
    };
    WebGlStage.prototype.destroyRenderer = function(renderer) {
      var rendererInstances = this._rendererInstances;
      if (this._renderers.indexOf(renderer) < 0) {
        renderer.destroy();
        var index = rendererInstances.indexOf(renderer);
        if (index >= 0) {
          rendererInstances.splice(index, 1);
        }
      }
    };
    WebGlStage.prototype.startFrame = function() {
      var gl = this._gl;
      if (!gl) {
        throw new Error("Bad WebGL context - maybe context was lost?");
      }
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    };
    WebGlStage.prototype.endFrame = function() {
    };
    WebGlStage.prototype.takeSnapshot = function(options) {
      if (typeof options !== "object" || options == null) {
        options = {};
      }
      var quality = options.quality;
      if (typeof quality == "undefined") {
        quality = 75;
      }
      if (typeof quality !== "number" || quality < 0 || quality > 100) {
        throw new Error("WebGLStage: Snapshot quality needs to be a number between 0 and 100");
      }
      this.render();
      return this._domElement.toDataURL("image/jpeg", quality / 100);
    };
    WebGlStage.type = WebGlStage.prototype.type = "webgl";
    function WebGlTexture(stage, tile2, asset) {
      this._stage = stage;
      this._gl = stage._gl;
      this._texture = null;
      this._timestamp = null;
      this._width = this._height = null;
      this.refresh(tile2, asset);
    }
    WebGlTexture.prototype.refresh = function(tile2, asset) {
      var gl = this._gl;
      var stage = this._stage;
      var texture;
      var timestamp = asset.timestamp();
      if (timestamp === this._timestamp) {
        return;
      }
      var element = asset.element();
      var width = asset.width();
      var height = asset.height();
      if (width !== this._width || height !== this._height) {
        var maxSize = stage.maxTextureSize();
        if (width > maxSize) {
          throw new Error("Texture width larger than max size (" + width + " vs. " + maxSize + ")");
        }
        if (height > maxSize) {
          throw new Error("Texture height larger than max size (" + height + " vs. " + maxSize + ")");
        }
        if (this._texture) {
          gl.deleteTexture(texture);
        }
        texture = this._texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);
      } else {
        texture = this._texture;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        if (element instanceof HTMLVideoElement && browserQuirks.videoUseTexImage2D) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, element);
        }
      }
      if (stage._generateMipmaps && ispot(width) && ispot(height)) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.generateMipmap(gl.TEXTURE_2D);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      this._timestamp = timestamp;
      this._width = width;
      this._height = height;
    };
    WebGlTexture.prototype.destroy = function() {
      if (this._texture) {
        this._gl.deleteTexture(this._texture);
      }
      clearOwnProperties(this);
    };
    WebGlStage.TextureClass = WebGlStage.prototype.TextureClass = WebGlTexture;
    module.exports = WebGlStage;
  }
});

// node_modules/gl-matrix/esm/common.js
var common_exports = {};
__export(common_exports, {
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals,
  setMatrixArrayType: () => setMatrixArrayType,
  toRadian: () => toRadian
});
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
function toRadian(a) {
  return a * degree;
}
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}
var EPSILON, ARRAY_TYPE, RANDOM, degree;
var init_common = __esm({
  "node_modules/gl-matrix/esm/common.js"() {
    EPSILON = 1e-6;
    ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
    RANDOM = Math.random;
    degree = Math.PI / 180;
    if (!Math.hypot)
      Math.hypot = function() {
        var y = 0, i = arguments.length;
        while (i--) {
          y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
      };
  }
});

// node_modules/gl-matrix/esm/mat2.js
var mat2_exports = {};
__export(mat2_exports, {
  LDU: () => LDU,
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}
function invert(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
function adjoint(out, a) {
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
function multiply(out, a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
function rotate(out, a, rad) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
function scale(out, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  out[2] = a[2] + b[2] * scale10;
  out[3] = a[3] + b[3] * scale10;
  return out;
}
var mul, sub;
var init_mat2 = __esm({
  "node_modules/gl-matrix/esm/mat2.js"() {
    init_common();
    mul = multiply;
    sub = subtract;
  }
});

// node_modules/gl-matrix/esm/mat2d.js
var mat2d_exports = {};
__export(mat2d_exports, {
  add: () => add2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromRotation: () => fromRotation2,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues2,
  identity: () => identity2,
  invert: () => invert2,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  rotate: () => rotate2,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  translate: () => translate
});
function create2() {
  var out = new ARRAY_TYPE(6);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
function fromValues2(a, b, c, d, tx, ty) {
  var out = new ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
function set2(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
function invert2(out, a) {
  var aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  var atx = a[4], aty = a[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
function determinant2(a) {
  return a[0] * a[3] - a[1] * a[2];
}
function multiply2(out, a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
function rotate2(out, a, rad) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
function scale2(out, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  var v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
function translate(out, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  var v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
function fromRotation2(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
function str2(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  out[2] = a[2] + b[2] * scale10;
  out[3] = a[3] + b[3] * scale10;
  out[4] = a[4] + b[4] * scale10;
  out[5] = a[5] + b[5] * scale10;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
}
var mul2, sub2;
var init_mat2d = __esm({
  "node_modules/gl-matrix/esm/mat2d.js"() {
    init_common();
    mul2 = multiply2;
    sub2 = subtract2;
  }
});

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add3,
  adjoint: () => adjoint2,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  determinant: () => determinant3,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  frob: () => frob3,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation3,
  fromScaling: () => fromScaling3,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues3,
  identity: () => identity3,
  invert: () => invert3,
  mul: () => mul3,
  multiply: () => multiply3,
  multiplyScalar: () => multiplyScalar3,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd3,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate3,
  scale: () => scale3,
  set: () => set3,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  translate: () => translate2,
  transpose: () => transpose2
});
function create3() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues3(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set3(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert3(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant3(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply3(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate2(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate3(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale3(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation3(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling3(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str3(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob3(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd3(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  out[2] = a[2] + b[2] * scale10;
  out[3] = a[3] + b[3] * scale10;
  out[4] = a[4] + b[4] * scale10;
  out[5] = a[5] + b[5] * scale10;
  out[6] = a[6] + b[6] * scale10;
  out[7] = a[7] + b[7] * scale10;
  out[8] = a[8] + b[8] * scale10;
  return out;
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul3, sub3;
var init_mat3 = __esm({
  "node_modules/gl-matrix/esm/mat3.js"() {
    init_common();
    mul3 = multiply3;
    sub3 = subtract3;
  }
});

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add4,
  adjoint: () => adjoint3,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  determinant: () => determinant4,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  frob: () => frob4,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation4,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling4,
  fromTranslation: () => fromTranslation3,
  fromValues: () => fromValues4,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity4,
  invert: () => invert4,
  lookAt: () => lookAt,
  mul: () => mul4,
  multiply: () => multiply4,
  multiplyScalar: () => multiplyScalar4,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd4,
  ortho: () => ortho,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  rotate: () => rotate4,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale4,
  set: () => set4,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  targetTo: () => targetTo,
  translate: () => translate3,
  transpose: () => transpose3
});
function create4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set4(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity4(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose3(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint3(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant4(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply4(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate3(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale4(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate4(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len6 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len6 < EPSILON) {
    return null;
  }
  len6 = 1 / len6;
  x *= len6;
  y *= len6;
  z *= len6;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation3(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling4(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation4(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len6 = Math.hypot(x, y, z);
  var s, c, t;
  if (len6 < EPSILON) {
    return null;
  }
  len6 = 1 / len6;
  x *= len6;
  y *= len6;
  z *= len6;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspective(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len6;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity4(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len6 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len6;
  z1 *= len6;
  z2 *= len6;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len6 = Math.hypot(x0, x1, x2);
  if (!len6) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len6 = 1 / len6;
    x0 *= len6;
    x1 *= len6;
    x2 *= len6;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len6 = Math.hypot(y0, y1, y2);
  if (!len6) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len6 = 1 / len6;
    y0 *= len6;
    y1 *= len6;
    y2 *= len6;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len6 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    z0 *= len6;
    z1 *= len6;
    z2 *= len6;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len6 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    x0 *= len6;
    x1 *= len6;
    x2 *= len6;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str4(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob4(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd4(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  out[2] = a[2] + b[2] * scale10;
  out[3] = a[3] + b[3] * scale10;
  out[4] = a[4] + b[4] * scale10;
  out[5] = a[5] + b[5] * scale10;
  out[6] = a[6] + b[6] * scale10;
  out[7] = a[7] + b[7] * scale10;
  out[8] = a[8] + b[8] * scale10;
  out[9] = a[9] + b[9] * scale10;
  out[10] = a[10] + b[10] * scale10;
  out[11] = a[11] + b[11] * scale10;
  out[12] = a[12] + b[12] * scale10;
  out[13] = a[13] + b[13] * scale10;
  out[14] = a[14] + b[14] * scale10;
  out[15] = a[15] + b[15] * scale10;
  return out;
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul4, sub4;
var init_mat4 = __esm({
  "node_modules/gl-matrix/esm/mat4.js"() {
    init_common();
    mul4 = multiply4;
    sub4 = subtract4;
  }
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add5,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues5,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul5,
  multiply: () => multiply5,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set5,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str5,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create5() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone5(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues5(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set5(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply5(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale5(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  out[2] = a[2] + b[2] * scale10;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len6 = x * x + y * y + z * z;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  out[2] = a[2] * len6;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale10) {
  scale10 = scale10 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale10;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale10;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str5(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals5(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals6(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub5, mul5, div, dist, sqrDist, len, sqrLen, forEach;
var init_vec3 = __esm({
  "node_modules/gl-matrix/esm/vec3.js"() {
    init_common();
    sub5 = subtract5;
    mul5 = multiply5;
    div = divide;
    dist = distance;
    sqrDist = squaredDistance;
    len = length;
    sqrLen = squaredLength;
    forEach = function() {
      var vec = create5();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 3;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
        }
        return a;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add6,
  ceil: () => ceil2,
  clone: () => clone6,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals7,
  exactEquals: () => exactEquals6,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues6,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set6,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str6,
  sub: () => sub6,
  subtract: () => subtract6,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone6(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues6(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set6(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract6(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply6(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  out[2] = a[2] + b[2] * scale10;
  out[3] = a[3] + b[3] * scale10;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len6 = x * x + y * y + z * z + w * w;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = x * len6;
  out[1] = y * len6;
  out[2] = z * len6;
  out[3] = w * len6;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale10) {
  scale10 = scale10 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale10 * v1;
  out[1] = scale10 * v2;
  out[2] = scale10 * v3 * d;
  out[3] = scale10 * v4 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str6(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals7(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub6, mul6, div2, dist2, sqrDist2, len2, sqrLen2, forEach2;
var init_vec4 = __esm({
  "node_modules/gl-matrix/esm/vec4.js"() {
    init_common();
    sub6 = subtract6;
    mul6 = multiply6;
    div2 = divide2;
    dist2 = distance2;
    sqrDist2 = squaredDistance2;
    len2 = length2;
    sqrLen2 = squaredLength2;
    forEach2 = function() {
      var vec = create6();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 4;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          vec[3] = a[i + 3];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
          a[i + 3] = vec[3];
        }
        return a;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add7,
  calculateW: () => calculateW,
  clone: () => clone7,
  conjugate: () => conjugate,
  copy: () => copy7,
  create: () => create7,
  dot: () => dot3,
  equals: () => equals8,
  exactEquals: () => exactEquals7,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues7,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity5,
  invert: () => invert5,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul7,
  multiply: () => multiply7,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale7,
  set: () => set7,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str7
});
function create7() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity5(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply7(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale7(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert5(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot6 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot6 ? 1 / dot6 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str7(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone7, fromValues7, copy7, set7, add7, mul7, scale7, dot3, lerp3, length3, len3, squaredLength3, sqrLen3, normalize3, exactEquals7, equals8, rotationTo, sqlerp, setAxes;
var init_quat = __esm({
  "node_modules/gl-matrix/esm/quat.js"() {
    init_common();
    init_mat3();
    init_vec3();
    init_vec4();
    clone7 = clone6;
    fromValues7 = fromValues6;
    copy7 = copy6;
    set7 = set6;
    add7 = add6;
    mul7 = multiply7;
    scale7 = scale6;
    dot3 = dot2;
    lerp3 = lerp2;
    length3 = length2;
    len3 = length3;
    squaredLength3 = squaredLength2;
    sqrLen3 = squaredLength3;
    normalize3 = normalize2;
    exactEquals7 = exactEquals6;
    equals8 = equals7;
    rotationTo = function() {
      var tmpvec3 = create5();
      var xUnitVec3 = fromValues5(1, 0, 0);
      var yUnitVec3 = fromValues5(0, 1, 0);
      return function(out, a, b) {
        var dot6 = dot(a, b);
        if (dot6 < -0.999999) {
          cross(tmpvec3, xUnitVec3, a);
          if (len(tmpvec3) < 1e-6)
            cross(tmpvec3, yUnitVec3, a);
          normalize(tmpvec3, tmpvec3);
          setAxisAngle(out, tmpvec3, Math.PI);
          return out;
        } else if (dot6 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross(tmpvec3, a, b);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot6;
          return normalize3(out, out);
        }
      };
    }();
    sqlerp = function() {
      var temp1 = create7();
      var temp2 = create7();
      return function(out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
      };
    }();
    setAxes = function() {
      var matr = create3();
      return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize3(out, fromMat3(out, matr));
      };
    }();
  }
});

// node_modules/gl-matrix/esm/quat2.js
var quat2_exports = {};
__export(quat2_exports, {
  add: () => add8,
  clone: () => clone8,
  conjugate: () => conjugate2,
  copy: () => copy8,
  create: () => create8,
  dot: () => dot4,
  equals: () => equals9,
  exactEquals: () => exactEquals8,
  fromMat4: () => fromMat42,
  fromRotation: () => fromRotation5,
  fromRotationTranslation: () => fromRotationTranslation2,
  fromRotationTranslationValues: () => fromRotationTranslationValues,
  fromTranslation: () => fromTranslation4,
  fromValues: () => fromValues8,
  getDual: () => getDual,
  getReal: () => getReal,
  getTranslation: () => getTranslation2,
  identity: () => identity6,
  invert: () => invert6,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  mul: () => mul8,
  multiply: () => multiply8,
  normalize: () => normalize4,
  rotateAroundAxis: () => rotateAroundAxis,
  rotateByQuatAppend: () => rotateByQuatAppend,
  rotateByQuatPrepend: () => rotateByQuatPrepend,
  rotateX: () => rotateX4,
  rotateY: () => rotateY4,
  rotateZ: () => rotateZ4,
  scale: () => scale8,
  set: () => set8,
  setDual: () => setDual,
  setReal: () => setReal,
  sqrLen: () => sqrLen4,
  squaredLength: () => squaredLength4,
  str: () => str8,
  translate: () => translate4
});
function create8() {
  var dq = new ARRAY_TYPE(8);
  if (ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}
function clone8(a) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
function fromValues8(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
function fromRotationTranslation2(out, q, t) {
  var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
function fromTranslation4(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
function fromRotation5(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function fromMat42(out, a) {
  var outer = create7();
  getRotation(outer, a);
  var t = new ARRAY_TYPE(3);
  getTranslation(t, a);
  fromRotationTranslation2(out, outer, t);
  return out;
}
function copy8(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
function identity6(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function set8(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
function getTranslation2(out, a) {
  var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
function translate4(out, a, v) {
  var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
function rotateX4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateX3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateY4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateY3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateZ4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateZ3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateByQuatAppend(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
function rotateByQuatPrepend(out, q, a) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
function rotateAroundAxis(out, a, axis, rad) {
  if (Math.abs(rad) < EPSILON) {
    return copy8(out, a);
  }
  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4], ay = a[5], az = a[6], aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function add8(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
function multiply8(out, a, b) {
  var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
function scale8(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
function lerp4(out, a, b, t) {
  var mt = 1 - t;
  if (dot4(a, b) < 0)
    t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
function invert6(out, a) {
  var sqlen = squaredLength4(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
function conjugate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
function normalize4(out, a) {
  var magnitude = squaredLength4(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}
function str8(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
function exactEquals8(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals9(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}
var getReal, setReal, mul8, dot4, length4, len4, squaredLength4, sqrLen4;
var init_quat2 = __esm({
  "node_modules/gl-matrix/esm/quat2.js"() {
    init_common();
    init_quat();
    init_mat4();
    getReal = copy7;
    setReal = copy7;
    mul8 = multiply8;
    dot4 = dot3;
    length4 = length3;
    len4 = length4;
    squaredLength4 = squaredLength3;
    sqrLen4 = squaredLength4;
  }
});

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add9,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone9,
  copy: () => copy9,
  create: () => create9,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot5,
  equals: () => equals10,
  exactEquals: () => exactEquals9,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues9,
  inverse: () => inverse3,
  len: () => len5,
  length: () => length5,
  lerp: () => lerp5,
  max: () => max3,
  min: () => min3,
  mul: () => mul9,
  multiply: () => multiply9,
  negate: () => negate3,
  normalize: () => normalize5,
  random: () => random4,
  rotate: () => rotate5,
  round: () => round3,
  scale: () => scale9,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set9,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen5,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength5,
  str: () => str9,
  sub: () => sub7,
  subtract: () => subtract7,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create9() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone9(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues9(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy9(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set9(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add9(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract7(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply9(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale9(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale10) {
  out[0] = a[0] + b[0] * scale10;
  out[1] = a[1] + b[1] * scale10;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length5(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength5(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize5(out, a) {
  var x = a[0], y = a[1];
  var len6 = x * x + y * y;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  return out;
}
function dot5(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp5(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale10) {
  scale10 = scale10 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale10;
  out[1] = Math.sin(r) * scale10;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate5(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str9(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals9(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals10(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len5, sub7, mul9, div3, dist3, sqrDist3, sqrLen5, forEach3;
var init_vec2 = __esm({
  "node_modules/gl-matrix/esm/vec2.js"() {
    init_common();
    len5 = length5;
    sub7 = subtract7;
    mul9 = multiply9;
    div3 = divide3;
    dist3 = distance3;
    sqrDist3 = squaredDistance3;
    sqrLen5 = squaredLength5;
    forEach3 = function() {
      var vec = create9();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 2;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
        }
        return a;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  glMatrix: () => common_exports,
  mat2: () => mat2_exports,
  mat2d: () => mat2d_exports,
  mat3: () => mat3_exports,
  mat4: () => mat4_exports,
  quat: () => quat_exports,
  quat2: () => quat2_exports,
  vec2: () => vec2_exports,
  vec3: () => vec3_exports,
  vec4: () => vec4_exports
});
var init_esm = __esm({
  "node_modules/gl-matrix/esm/index.js"() {
    init_common();
    init_mat2();
    init_mat2d();
    init_mat3();
    init_mat4();
    init_quat();
    init_quat2();
    init_vec2();
    init_vec3();
    init_vec4();
  }
});

// node_modules/marzipano/src/util/clamp.js
var require_clamp = __commonJS({
  "node_modules/marzipano/src/util/clamp.js"(exports, module) {
    "use strict";
    function clamp(value, min4, max4) {
      return Math.min(Math.max(value, min4), max4);
    }
    module.exports = clamp;
  }
});

// node_modules/marzipano/src/renderers/WebGlCommon.js
var require_WebGlCommon = __commonJS({
  "node_modules/marzipano/src/renderers/WebGlCommon.js"(exports, module) {
    "use strict";
    var MAX_LAYERS = 256;
    var MAX_LEVELS = 256;
    var clamp = require_clamp();
    var vec4 = (init_esm(), __toCommonJS(esm_exports)).vec4;
    var vec3 = (init_esm(), __toCommonJS(esm_exports)).vec3;
    var mat4 = (init_esm(), __toCommonJS(esm_exports)).mat4;
    function createShader(gl, type, src) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw gl.getShaderInfoLog(shader);
      }
      return shader;
    }
    function createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList) {
      var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
      var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
      var shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        throw gl.getProgramInfoLog(shaderProgram);
      }
      for (var i = 0; i < attribList.length; i++) {
        var attrib = attribList[i];
        shaderProgram[attrib] = gl.getAttribLocation(shaderProgram, attrib);
        if (shaderProgram[attrib] === -1) {
          throw new Error("Shader program has no " + attrib + " attribute");
        }
      }
      for (var j = 0; j < uniformList.length; j++) {
        var uniform = uniformList[j];
        shaderProgram[uniform] = gl.getUniformLocation(shaderProgram, uniform);
        if (shaderProgram[uniform] === -1) {
          throw new Error("Shader program has no " + uniform + " uniform");
        }
      }
      return shaderProgram;
    }
    function destroyShaderProgram(gl, shaderProgram) {
      var shaderList = gl.getAttachedShaders(shaderProgram);
      for (var i = 0; i < shaderList.length; i++) {
        var shader = shaderList[i];
        gl.detachShader(shaderProgram, shader);
        gl.deleteShader(shader);
      }
      gl.deleteProgram(shaderProgram);
    }
    function createConstantBuffer(gl, target, usage, value) {
      var buffer = gl.createBuffer();
      gl.bindBuffer(target, buffer);
      gl.bufferData(target, value, usage);
      return buffer;
    }
    function createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords) {
      return {
        vertexIndices: createConstantBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, new Uint16Array(vertexIndices)),
        vertexPositions: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(vertexPositions)),
        textureCoords: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(textureCoords))
      };
    }
    function destroyConstantBuffers(gl, constantBuffers) {
      gl.deleteBuffer(constantBuffers.vertexIndices);
      gl.deleteBuffer(constantBuffers.vertexPositions);
      gl.deleteBuffer(constantBuffers.textureCoords);
    }
    function enableAttributes(gl, shaderProgram) {
      var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
      for (var i = 0; i < numAttrs; i++) {
        gl.enableVertexAttribArray(i);
      }
    }
    function disableAttributes(gl, shaderProgram) {
      var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
      for (var i = 0; i < numAttrs; i++) {
        gl.disableVertexAttribArray(i);
      }
    }
    function setTexture(gl, shaderProgram, texture) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture._texture);
      gl.uniform1i(shaderProgram.uSampler, 0);
    }
    function setDepth(gl, shaderProgram, layerZ, tileZ) {
      var depth = ((layerZ + 1) * MAX_LEVELS - tileZ) / (MAX_LEVELS * MAX_LAYERS);
      gl.uniform1f(shaderProgram.uDepth, depth);
    }
    var defaultOpacity = 1;
    var defaultColorOffset = vec4.create();
    var defaultColorMatrix = mat4.create();
    mat4.identity(defaultColorMatrix);
    function setupPixelEffectUniforms(gl, effects, uniforms) {
      var opacity = defaultOpacity;
      if (effects && effects.opacity != null) {
        opacity = effects.opacity;
      }
      gl.uniform1f(uniforms.opacity, opacity);
      var colorOffset = defaultColorOffset;
      if (effects && effects.colorOffset) {
        colorOffset = effects.colorOffset;
      }
      gl.uniform4fv(uniforms.colorOffset, colorOffset);
      var colorMatrix = defaultColorMatrix;
      if (effects && effects.colorMatrix) {
        colorMatrix = effects.colorMatrix;
      }
      gl.uniformMatrix4fv(uniforms.colorMatrix, false, colorMatrix);
    }
    var translateVector = vec3.create();
    var scaleVector = vec3.create();
    function setViewport(gl, layer, rect, viewportMatrix) {
      if (rect.x === 0 && rect.width === 1 && rect.y === 0 && rect.height === 1) {
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        mat4.identity(viewportMatrix);
        return;
      }
      var offsetX = rect.x;
      var clampedOffsetX = clamp(offsetX, 0, 1);
      var leftExcess = clampedOffsetX - offsetX;
      var maxClampedWidth = 1 - clampedOffsetX;
      var clampedWidth = clamp(rect.width - leftExcess, 0, maxClampedWidth);
      var rightExcess = rect.width - clampedWidth;
      var offsetY = 1 - rect.height - rect.y;
      var clampedOffsetY = clamp(offsetY, 0, 1);
      var bottomExcess = clampedOffsetY - offsetY;
      var maxClampedHeight = 1 - clampedOffsetY;
      var clampedHeight = clamp(rect.height - bottomExcess, 0, maxClampedHeight);
      var topExcess = rect.height - clampedHeight;
      vec3.set(
        scaleVector,
        rect.width / clampedWidth,
        rect.height / clampedHeight,
        1
      );
      vec3.set(
        translateVector,
        (rightExcess - leftExcess) / clampedWidth,
        (topExcess - bottomExcess) / clampedHeight,
        0
      );
      mat4.identity(viewportMatrix);
      mat4.translate(viewportMatrix, viewportMatrix, translateVector);
      mat4.scale(viewportMatrix, viewportMatrix, scaleVector);
      gl.viewport(
        gl.drawingBufferWidth * clampedOffsetX,
        gl.drawingBufferHeight * clampedOffsetY,
        gl.drawingBufferWidth * clampedWidth,
        gl.drawingBufferHeight * clampedHeight
      );
    }
    module.exports = {
      createShaderProgram,
      destroyShaderProgram,
      createConstantBuffers,
      destroyConstantBuffers,
      enableAttributes,
      disableAttributes,
      setTexture,
      setDepth,
      setViewport,
      setupPixelEffectUniforms
    };
  }
});

// node_modules/marzipano/src/shaders/vertexNormal.js
var require_vertexNormal = __commonJS({
  "node_modules/marzipano/src/shaders/vertexNormal.js"(exports, module) {
    "use strict";
    module.exports = [
      "attribute vec3 aVertexPosition;",
      "attribute vec2 aTextureCoord;",
      "uniform float uDepth;",
      "uniform mat4 uViewportMatrix;",
      "uniform mat4 uProjMatrix;",
      "varying vec2 vTextureCoord;",
      "void main(void) {",
      "  gl_Position = uViewportMatrix * uProjMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);",
      "  gl_Position.z = uDepth * gl_Position.w;",
      "  vTextureCoord = aTextureCoord;",
      "}"
    ].join("\n");
  }
});

// node_modules/marzipano/src/shaders/fragmentNormal.js
var require_fragmentNormal = __commonJS({
  "node_modules/marzipano/src/shaders/fragmentNormal.js"(exports, module) {
    "use strict";
    module.exports = [
      "#ifdef GL_FRAGMENT_PRECISION_HIGH",
      "precision highp float;",
      "#else",
      "precision mediump float;",
      "#endif",
      "uniform sampler2D uSampler;",
      "uniform float uOpacity;",
      "uniform vec4 uColorOffset;",
      "uniform mat4 uColorMatrix;",
      "varying vec2 vTextureCoord;",
      "void main(void) {",
      "  vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;",
      "  gl_FragColor = vec4(color.rgba * uOpacity);",
      "}"
    ].join("\n");
  }
});

// node_modules/marzipano/src/renderers/WebGlBase.js
var require_WebGlBase = __commonJS({
  "node_modules/marzipano/src/renderers/WebGlBase.js"(exports, module) {
    "use strict";
    var mat4 = (init_esm(), __toCommonJS(esm_exports)).mat4;
    var vec3 = (init_esm(), __toCommonJS(esm_exports)).vec3;
    var clearOwnProperties = require_clearOwnProperties();
    var WebGlCommon = require_WebGlCommon();
    var createConstantBuffers = WebGlCommon.createConstantBuffers;
    var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
    var createShaderProgram = WebGlCommon.createShaderProgram;
    var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
    var enableAttributes = WebGlCommon.enableAttributes;
    var disableAttributes = WebGlCommon.disableAttributes;
    var setViewport = WebGlCommon.setViewport;
    var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;
    var setDepth = WebGlCommon.setDepth;
    var setTexture = WebGlCommon.setTexture;
    var vertexSrc = require_vertexNormal();
    var fragmentSrc = require_fragmentNormal();
    var vertexIndices = [0, 1, 2, 0, 2, 3];
    var vertexPositions = [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0];
    var textureCoords = [0, 0, 1, 0, 1, 1, 0, 1];
    var attribList = ["aVertexPosition", "aTextureCoord"];
    var uniformList = [
      "uDepth",
      "uOpacity",
      "uSampler",
      "uProjMatrix",
      "uViewportMatrix",
      "uColorOffset",
      "uColorMatrix"
    ];
    function WebGlBaseRenderer(gl) {
      this.gl = gl;
      this.projMatrix = mat4.create();
      this.viewportMatrix = mat4.create();
      this.translateVector = vec3.create();
      this.scaleVector = vec3.create();
      this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);
      this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
    }
    WebGlBaseRenderer.prototype.destroy = function() {
      destroyConstantBuffers(this.gl, this.constantBuffers);
      destroyShaderProgram(this.gl, this.shaderProgram);
      clearOwnProperties(this);
    };
    WebGlBaseRenderer.prototype.startLayer = function(layer, rect) {
      var gl = this.gl;
      var shaderProgram = this.shaderProgram;
      var constantBuffers = this.constantBuffers;
      var viewportMatrix = this.viewportMatrix;
      gl.useProgram(shaderProgram);
      enableAttributes(gl, shaderProgram);
      setViewport(gl, layer, rect, viewportMatrix);
      gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);
      gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
      gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
      gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);
      setupPixelEffectUniforms(gl, layer.effects(), {
        opacity: shaderProgram.uOpacity,
        colorOffset: shaderProgram.uColorOffset,
        colorMatrix: shaderProgram.uColorMatrix
      });
    };
    WebGlBaseRenderer.prototype.endLayer = function(layer, rect) {
      var gl = this.gl;
      var shaderProgram = this.shaderProgram;
      disableAttributes(gl, shaderProgram);
    };
    WebGlBaseRenderer.prototype.renderTile = function(tile2, texture, layer, layerZ) {
      var gl = this.gl;
      var shaderProgram = this.shaderProgram;
      var constantBuffers = this.constantBuffers;
      var projMatrix = this.projMatrix;
      var translateVector = this.translateVector;
      var scaleVector = this.scaleVector;
      translateVector[0] = tile2.centerX();
      translateVector[1] = tile2.centerY();
      translateVector[2] = -0.5;
      scaleVector[0] = tile2.scaleX();
      scaleVector[1] = tile2.scaleY();
      scaleVector[2] = 1;
      mat4.copy(projMatrix, layer.view().projection());
      mat4.rotateX(projMatrix, projMatrix, tile2.rotX());
      mat4.rotateY(projMatrix, projMatrix, tile2.rotY());
      mat4.translate(projMatrix, projMatrix, translateVector);
      mat4.scale(projMatrix, projMatrix, scaleVector);
      gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);
      setDepth(gl, shaderProgram, layerZ, tile2.z);
      setTexture(gl, shaderProgram, texture);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
      gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
    };
    module.exports = WebGlBaseRenderer;
  }
});

// node_modules/marzipano/src/renderers/WebGlCube.js
var require_WebGlCube = __commonJS({
  "node_modules/marzipano/src/renderers/WebGlCube.js"(exports, module) {
    "use strict";
    var WebGlBaseRenderer = require_WebGlBase();
    var inherits = require_inherits();
    function WebGlCubeRenderer() {
      this.constructor.super_.apply(this, arguments);
    }
    inherits(WebGlCubeRenderer, WebGlBaseRenderer);
    module.exports = WebGlCubeRenderer;
  }
});

// node_modules/marzipano/src/renderers/WebGlFlat.js
var require_WebGlFlat = __commonJS({
  "node_modules/marzipano/src/renderers/WebGlFlat.js"(exports, module) {
    "use strict";
    var WebGlBaseRenderer = require_WebGlBase();
    var inherits = require_inherits();
    function WebGlFlatRenderer() {
      this.constructor.super_.apply(this, arguments);
    }
    inherits(WebGlFlatRenderer, WebGlBaseRenderer);
    module.exports = WebGlFlatRenderer;
  }
});

// node_modules/marzipano/src/shaders/vertexEquirect.js
var require_vertexEquirect = __commonJS({
  "node_modules/marzipano/src/shaders/vertexEquirect.js"(exports, module) {
    "use strict";
    module.exports = [
      "attribute vec3 aVertexPosition;",
      "uniform float uDepth;",
      "uniform mat4 uViewportMatrix;",
      "uniform mat4 uInvProjMatrix;",
      "varying vec4 vRay;",
      "void main(void) {",
      "  vRay = uInvProjMatrix * vec4(aVertexPosition.xy, 1.0, 1.0);",
      "  gl_Position = uViewportMatrix * vec4(aVertexPosition.xy, uDepth, 1.0);",
      "}"
    ].join("\n");
  }
});

// node_modules/marzipano/src/shaders/fragmentEquirect.js
var require_fragmentEquirect = __commonJS({
  "node_modules/marzipano/src/shaders/fragmentEquirect.js"(exports, module) {
    "use strict";
    module.exports = [
      "#ifdef GL_FRAGMENT_PRECISION_HIGH",
      "precision highp float;",
      "#else",
      "precision mediump float",
      "#endif",
      "uniform sampler2D uSampler;",
      "uniform float uOpacity;",
      "uniform float uTextureX;",
      "uniform float uTextureY;",
      "uniform float uTextureWidth;",
      "uniform float uTextureHeight;",
      "uniform vec4 uColorOffset;",
      "uniform mat4 uColorMatrix;",
      "varying vec4 vRay;",
      "const float PI = 3.14159265358979323846264;",
      "void main(void) {",
      "  float r = inversesqrt(vRay.x * vRay.x + vRay.y * vRay.y + vRay.z * vRay.z);",
      "  float phi  = acos(vRay.y * r);",
      "  float theta = atan(vRay.x, -1.0*vRay.z);",
      "  float s = 0.5 + 0.5 * theta / PI;",
      "  float t = 1.0 - phi / PI;",
      "  s = s * uTextureWidth + uTextureX;",
      "  t = t * uTextureHeight + uTextureY;",
      "  vec4 color = texture2D(uSampler, vec2(s, t)) * uColorMatrix + uColorOffset;",
      "  gl_FragColor = vec4(color.rgba * uOpacity);",
      "}"
    ].join("\n");
  }
});

// node_modules/marzipano/src/renderers/WebGlEquirect.js
var require_WebGlEquirect = __commonJS({
  "node_modules/marzipano/src/renderers/WebGlEquirect.js"(exports, module) {
    "use strict";
    var mat4 = (init_esm(), __toCommonJS(esm_exports)).mat4;
    var clearOwnProperties = require_clearOwnProperties();
    var WebGlCommon = require_WebGlCommon();
    var createConstantBuffers = WebGlCommon.createConstantBuffers;
    var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
    var createShaderProgram = WebGlCommon.createShaderProgram;
    var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
    var enableAttributes = WebGlCommon.enableAttributes;
    var disableAttributes = WebGlCommon.disableAttributes;
    var setViewport = WebGlCommon.setViewport;
    var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;
    var setDepth = WebGlCommon.setDepth;
    var setTexture = WebGlCommon.setTexture;
    var vertexSrc = require_vertexEquirect();
    var fragmentSrc = require_fragmentEquirect();
    var vertexIndices = [0, 1, 2, 0, 2, 3];
    var vertexPositions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
    var textureCoords = [0, 0, 1, 0, 1, 1, 0, 1];
    var attribList = ["aVertexPosition"];
    var uniformList = [
      "uDepth",
      "uOpacity",
      "uSampler",
      "uInvProjMatrix",
      "uViewportMatrix",
      "uColorOffset",
      "uColorMatrix",
      "uTextureX",
      "uTextureY",
      "uTextureWidth",
      "uTextureHeight"
    ];
    function WebGlEquirectRenderer(gl) {
      this.gl = gl;
      this.invProjMatrix = mat4.create();
      this.viewportMatrix = mat4.create();
      this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);
      this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
    }
    WebGlEquirectRenderer.prototype.destroy = function() {
      destroyConstantBuffers(this.gl, this.constantBuffers);
      destroyShaderProgram(this.gl, this.shaderProgram);
      clearOwnProperties(this);
    };
    WebGlEquirectRenderer.prototype.startLayer = function(layer, rect) {
      var gl = this.gl;
      var shaderProgram = this.shaderProgram;
      var constantBuffers = this.constantBuffers;
      var invProjMatrix = this.invProjMatrix;
      var viewportMatrix = this.viewportMatrix;
      gl.useProgram(shaderProgram);
      enableAttributes(gl, shaderProgram);
      setViewport(gl, layer, rect, viewportMatrix);
      gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);
      gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
      gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
      mat4.copy(invProjMatrix, layer.view().projection());
      mat4.invert(invProjMatrix, invProjMatrix);
      gl.uniformMatrix4fv(shaderProgram.uInvProjMatrix, false, invProjMatrix);
      var textureCrop = layer.effects().textureCrop || {};
      var textureX = textureCrop.x != null ? textureCrop.x : 0;
      var textureY = textureCrop.y != null ? textureCrop.y : 0;
      var textureWidth = textureCrop.width != null ? textureCrop.width : 1;
      var textureHeight = textureCrop.height != null ? textureCrop.height : 1;
      gl.uniform1f(shaderProgram.uTextureX, textureX);
      gl.uniform1f(shaderProgram.uTextureY, textureY);
      gl.uniform1f(shaderProgram.uTextureWidth, textureWidth);
      gl.uniform1f(shaderProgram.uTextureHeight, textureHeight);
      setupPixelEffectUniforms(gl, layer.effects(), {
        opacity: shaderProgram.uOpacity,
        colorOffset: shaderProgram.uColorOffset,
        colorMatrix: shaderProgram.uColorMatrix
      });
    };
    WebGlEquirectRenderer.prototype.endLayer = function(layer, rect) {
      var gl = this.gl;
      var shaderProgram = this.shaderProgram;
      disableAttributes(gl, shaderProgram);
    };
    WebGlEquirectRenderer.prototype.renderTile = function(tile2, texture, layer, layerZ) {
      var gl = this.gl;
      var shaderProgram = this.shaderProgram;
      var constantBuffers = this.constantBuffers;
      setDepth(gl, shaderProgram, layerZ, tile2.z);
      setTexture(gl, shaderProgram, texture);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
      gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
    };
    module.exports = WebGlEquirectRenderer;
  }
});

// node_modules/marzipano/src/renderers/registerDefaultRenderers.js
var require_registerDefaultRenderers = __commonJS({
  "node_modules/marzipano/src/renderers/registerDefaultRenderers.js"(exports, module) {
    "use strict";
    var WebGlCube = require_WebGlCube();
    var WebGlFlat = require_WebGlFlat();
    var WebGlEquirect = require_WebGlEquirect();
    function registerDefaultRenderers(stage) {
      switch (stage.type) {
        case "webgl":
          stage.registerRenderer("flat", "flat", WebGlFlat);
          stage.registerRenderer("cube", "rectilinear", WebGlCube);
          stage.registerRenderer("equirect", "rectilinear", WebGlEquirect);
          break;
        default:
          throw new Error("Unknown stage type: " + stage.type);
      }
    }
    module.exports = registerDefaultRenderers;
  }
});

// node_modules/marzipano/src/util/hash.js
var require_hash = __commonJS({
  "node_modules/marzipano/src/util/hash.js"(exports, module) {
    "use strict";
    function hash() {
      var h = 0;
      for (var i = 0; i < arguments.length; i++) {
        var k = arguments[i];
        h += k;
        h += k << 10;
        h ^= k >> 6;
      }
      h += h << 3;
      h ^= h >> 11;
      h += h << 15;
      return h >= 0 ? h : -h;
    }
    module.exports = hash;
  }
});

// node_modules/marzipano/src/util/mod.js
var require_mod = __commonJS({
  "node_modules/marzipano/src/util/mod.js"(exports, module) {
    "use strict";
    function mod(a, b) {
      return (+a % (b = +b) + b) % b;
    }
    module.exports = mod;
  }
});

// node_modules/marzipano/src/collections/Set.js
var require_Set = __commonJS({
  "node_modules/marzipano/src/collections/Set.js"(exports, module) {
    "use strict";
    var mod = require_mod();
    var defaultCapacity = 64;
    function Set(capacity) {
      if (capacity != null && (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
        throw new Error("Set: invalid capacity");
      }
      this._capacity = this._capacity || defaultCapacity;
      this._buckets = [];
      for (var i = 0; i < this._capacity; i++) {
        this._buckets.push([]);
      }
      this._size = 0;
    }
    Set.prototype.add = function(element) {
      var h = mod(element.hash(), this._capacity);
      var bucket = this._buckets[h];
      for (var i = 0; i < bucket.length; i++) {
        var existingElement = bucket[i];
        if (element.equals(existingElement)) {
          bucket[i] = element;
          return existingElement;
        }
      }
      bucket.push(element);
      this._size++;
      return null;
    };
    Set.prototype.remove = function(element) {
      var h = mod(element.hash(), this._capacity);
      var bucket = this._buckets[h];
      for (var i = 0; i < bucket.length; i++) {
        var existingElement = bucket[i];
        if (element.equals(existingElement)) {
          for (var j = i; j < bucket.length - 1; j++) {
            bucket[j] = bucket[j + 1];
          }
          bucket.length = bucket.length - 1;
          this._size--;
          return existingElement;
        }
      }
      return null;
    };
    Set.prototype.has = function(element) {
      var h = mod(element.hash(), this._capacity);
      var bucket = this._buckets[h];
      for (var i = 0; i < bucket.length; i++) {
        var existingElement = bucket[i];
        if (element.equals(existingElement)) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.size = function() {
      return this._size;
    };
    Set.prototype.clear = function() {
      for (var i = 0; i < this._capacity; i++) {
        this._buckets[i].length = 0;
      }
      this._size = 0;
    };
    Set.prototype.forEach = function(fn) {
      var count = 0;
      for (var i = 0; i < this._capacity; i++) {
        var bucket = this._buckets[i];
        for (var j = 0; j < bucket.length; j++) {
          fn(bucket[j]);
          count += 1;
        }
      }
      return count;
    };
    module.exports = Set;
  }
});

// node_modules/marzipano/src/TileSearcher.js
var require_TileSearcher = __commonJS({
  "node_modules/marzipano/src/TileSearcher.js"(exports, module) {
    "use strict";
    var Set = require_Set();
    function TileSearcher() {
      this._stack = [];
      this._visited = new Set();
      this._vertices = null;
    }
    TileSearcher.prototype.search = function(view, startingTile, result) {
      var stack = this._stack;
      var visited = this._visited;
      var vertices = this._vertices;
      var count = 0;
      this._clear();
      stack.push(startingTile);
      while (stack.length > 0) {
        var tile2 = stack.pop();
        if (visited.has(tile2)) {
          continue;
        }
        if (!view.intersects(tile2.vertices(vertices))) {
          continue;
        }
        visited.add(tile2);
        var neighbors = tile2.neighbors();
        for (var i = 0; i < neighbors.length; i++) {
          stack.push(neighbors[i]);
        }
        result.push(tile2);
        count++;
      }
      this._vertices = vertices;
      this._clear();
      return count;
    };
    TileSearcher.prototype._clear = function() {
      this._stack.length = 0;
      this._visited.clear();
    };
    module.exports = TileSearcher;
  }
});

// node_modules/marzipano/src/collections/LruMap.js
var require_LruMap = __commonJS({
  "node_modules/marzipano/src/collections/LruMap.js"(exports, module) {
    "use strict";
    var mod = require_mod();
    function LruMap(capacity) {
      if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
        throw new Error("LruMap: invalid capacity");
      }
      this._capacity = capacity;
      this._keys = new Array(this._capacity);
      this._values = new Array(this._capacity);
      this._start = 0;
      this._size = 0;
    }
    LruMap.prototype._index = function(i) {
      return mod(this._start + i, this._capacity);
    };
    LruMap.prototype.get = function(key) {
      for (var i = 0; i < this._size; i++) {
        var existingKey = this._keys[this._index(i)];
        if (key.equals(existingKey)) {
          return this._values[this._index(i)];
        }
      }
      return null;
    };
    LruMap.prototype.set = function(key, value) {
      if (this._capacity === 0) {
        return key;
      }
      this.del(key);
      var evictedKey = this._size === this._capacity ? this._keys[this._index(0)] : null;
      this._keys[this._index(this._size)] = key;
      this._values[this._index(this._size)] = value;
      if (this._size < this._capacity) {
        this._size++;
      } else {
        this._start = this._index(1);
      }
      return evictedKey;
    };
    LruMap.prototype.del = function(key) {
      for (var i = 0; i < this._size; i++) {
        if (key.equals(this._keys[this._index(i)])) {
          var existingValue = this._values[this._index(i)];
          for (var j = i; j < this._size - 1; j++) {
            this._keys[this._index(j)] = this._keys[this._index(j + 1)];
            this._values[this._index(j)] = this._values[this._index(j + 1)];
          }
          this._size--;
          return existingValue;
        }
      }
      return null;
    };
    LruMap.prototype.has = function(key) {
      for (var i = 0; i < this._size; i++) {
        if (key.equals(this._keys[this._index(i)])) {
          return true;
        }
      }
      return false;
    };
    LruMap.prototype.size = function() {
      return this._size;
    };
    LruMap.prototype.clear = function() {
      this._keys.length = 0;
      this._values.length = 0;
      this._start = 0;
      this._size = 0;
    };
    LruMap.prototype.forEach = function(fn) {
      var count = 0;
      for (var i = 0; i < this._size; i++) {
        fn(this._keys[this._index(i)], this._values[this._index(i)]);
        count += 1;
      }
      return count;
    };
    module.exports = LruMap;
  }
});

// node_modules/marzipano/src/geometries/Level.js
var require_Level = __commonJS({
  "node_modules/marzipano/src/geometries/Level.js"(exports, module) {
    "use strict";
    function Level(levelProperties) {
      this._fallbackOnly = !!levelProperties.fallbackOnly;
    }
    Level.prototype.numHorizontalTiles = function() {
      return Math.ceil(this.width() / this.tileWidth());
    };
    Level.prototype.numVerticalTiles = function() {
      return Math.ceil(this.height() / this.tileHeight());
    };
    Level.prototype.fallbackOnly = function() {
      return this._fallbackOnly;
    };
    module.exports = Level;
  }
});

// node_modules/marzipano/src/util/cmp.js
var require_cmp = __commonJS({
  "node_modules/marzipano/src/util/cmp.js"(exports, module) {
    "use strict";
    function cmp(x, y) {
      if (x < y) {
        return -1;
      }
      if (x > y) {
        return 1;
      }
      return 0;
    }
    module.exports = cmp;
  }
});

// node_modules/marzipano/src/geometries/common.js
var require_common = __commonJS({
  "node_modules/marzipano/src/geometries/common.js"(exports, module) {
    "use strict";
    var cmp = require_cmp();
    function makeLevelList(levelPropertiesList, LevelClass) {
      var list = [];
      for (var i = 0; i < levelPropertiesList.length; i++) {
        list.push(new LevelClass(levelPropertiesList[i]));
      }
      list.sort(function(level1, level2) {
        return cmp(level1.width(), level2.width());
      });
      return list;
    }
    function makeSelectableLevelList(levelList) {
      var list = [];
      for (var i = 0; i < levelList.length; i++) {
        if (!levelList[i]._fallbackOnly) {
          list.push(levelList[i]);
        }
      }
      if (!list.length) {
        throw new Error("No selectable levels in list");
      }
      return list;
    }
    module.exports = {
      makeLevelList,
      makeSelectableLevelList
    };
  }
});

// node_modules/marzipano/src/util/type.js
var require_type = __commonJS({
  "node_modules/marzipano/src/util/type.js"(exports, module) {
    "use strict";
    function type(x) {
      var typ = typeof x;
      if (typ === "object") {
        if (x === null) {
          return "null";
        }
        if (Object.prototype.toString.call(x) === "[object Array]") {
          return "array";
        }
        if (Object.prototype.toString.call(x) === "[object RegExp]") {
          return "regexp";
        }
      }
      return typ;
    }
    module.exports = type;
  }
});

// node_modules/marzipano/src/geometries/Cube.js
var require_Cube = __commonJS({
  "node_modules/marzipano/src/geometries/Cube.js"(exports, module) {
    "use strict";
    var inherits = require_inherits();
    var hash = require_hash();
    var TileSearcher = require_TileSearcher();
    var LruMap = require_LruMap();
    var Level = require_Level();
    var makeLevelList = require_common().makeLevelList;
    var makeSelectableLevelList = require_common().makeSelectableLevelList;
    var clamp = require_clamp();
    var cmp = require_cmp();
    var type = require_type();
    var vec3 = (init_esm(), __toCommonJS(esm_exports)).vec3;
    var vec4 = (init_esm(), __toCommonJS(esm_exports)).vec4;
    var neighborsCacheSize = 64;
    var faceList = "fudlrb";
    var faceRotation = {
      f: { x: 0, y: 0 },
      b: { x: 0, y: Math.PI },
      l: { x: 0, y: Math.PI / 2 },
      r: { x: 0, y: -Math.PI / 2 },
      u: { x: Math.PI / 2, y: 0 },
      d: { x: -Math.PI / 2, y: 0 }
    };
    var origin = vec3.create();
    function rotateVector(vec, z, x, y) {
      if (z) {
        vec3.rotateZ(vec, vec, origin, z);
      }
      if (x) {
        vec3.rotateX(vec, vec, origin, x);
      }
      if (y) {
        vec3.rotateY(vec, vec, origin, y);
      }
    }
    var faceVectors = {};
    for (i = 0; i < faceList.length; i++) {
      face = faceList[i];
      rotation = faceRotation[face];
      v = vec3.fromValues(0, 0, -1);
      rotateVector(v, 0, rotation.x, rotation.y);
      faceVectors[face] = v;
    }
    var face;
    var rotation;
    var v;
    var i;
    var adjacentFace = {
      f: ["l", "r", "u", "d"],
      b: ["r", "l", "u", "d"],
      l: ["b", "f", "u", "d"],
      r: ["f", "b", "u", "d"],
      u: ["l", "r", "b", "f"],
      d: ["l", "r", "f", "b"]
    };
    var neighborOffsets = [
      [0, 1],
      // top
      [1, 0],
      // right
      [0, -1],
      // bottom
      [-1, 0]
      // left
    ];
    function CubeTile(face2, x, y, z, geometry) {
      this.face = face2;
      this.x = x;
      this.y = y;
      this.z = z;
      this._geometry = geometry;
      this._level = geometry.levelList[z];
    }
    CubeTile.prototype.rotX = function() {
      return faceRotation[this.face].x;
    };
    CubeTile.prototype.rotY = function() {
      return faceRotation[this.face].y;
    };
    CubeTile.prototype.centerX = function() {
      return (this.x + 0.5) / this._level.numHorizontalTiles() - 0.5;
    };
    CubeTile.prototype.centerY = function() {
      return 0.5 - (this.y + 0.5) / this._level.numVerticalTiles();
    };
    CubeTile.prototype.scaleX = function() {
      return 1 / this._level.numHorizontalTiles();
    };
    CubeTile.prototype.scaleY = function() {
      return 1 / this._level.numVerticalTiles();
    };
    CubeTile.prototype.vertices = function(result) {
      if (!result) {
        result = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
      }
      var rot = faceRotation[this.face];
      function makeVertex(vec, x, y) {
        vec3.set(vec, x, y, -0.5);
        rotateVector(vec, 0, rot.x, rot.y);
      }
      var left = this.centerX() - this.scaleX() / 2;
      var right = this.centerX() + this.scaleX() / 2;
      var bottom = this.centerY() - this.scaleY() / 2;
      var top = this.centerY() + this.scaleY() / 2;
      makeVertex(result[0], left, top);
      makeVertex(result[1], right, top);
      makeVertex(result[2], right, bottom);
      makeVertex(result[3], left, bottom);
      return result;
    };
    CubeTile.prototype.parent = function() {
      if (this.z === 0) {
        return null;
      }
      var face2 = this.face;
      var z = this.z;
      var x = this.x;
      var y = this.y;
      var geometry = this._geometry;
      var level = geometry.levelList[z];
      var parentLevel = geometry.levelList[z - 1];
      var tileX = Math.floor(x / level.numHorizontalTiles() * parentLevel.numHorizontalTiles());
      var tileY = Math.floor(y / level.numVerticalTiles() * parentLevel.numVerticalTiles());
      var tileZ = z - 1;
      return new CubeTile(face2, tileX, tileY, tileZ, geometry);
    };
    CubeTile.prototype.children = function(result) {
      if (this.z === this._geometry.levelList.length - 1) {
        return null;
      }
      var face2 = this.face;
      var z = this.z;
      var x = this.x;
      var y = this.y;
      var geometry = this._geometry;
      var level = geometry.levelList[z];
      var childLevel = geometry.levelList[z + 1];
      var nHoriz = childLevel.numHorizontalTiles() / level.numHorizontalTiles();
      var nVert = childLevel.numVerticalTiles() / level.numVerticalTiles();
      result = result || [];
      for (var h = 0; h < nHoriz; h++) {
        for (var v2 = 0; v2 < nVert; v2++) {
          var tileX = nHoriz * x + h;
          var tileY = nVert * y + v2;
          var tileZ = z + 1;
          result.push(new CubeTile(face2, tileX, tileY, tileZ, geometry));
        }
      }
      return result;
    };
    CubeTile.prototype.neighbors = function() {
      var geometry = this._geometry;
      var cache = geometry._neighborsCache;
      var cachedResult = cache.get(this);
      if (cachedResult) {
        return cachedResult;
      }
      var vec = geometry._vec;
      var face2 = this.face;
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var level = this._level;
      var numX = level.numHorizontalTiles();
      var numY = level.numVerticalTiles();
      var result = [];
      for (var i2 = 0; i2 < neighborOffsets.length; i2++) {
        var xOffset = neighborOffsets[i2][0];
        var yOffset = neighborOffsets[i2][1];
        var newX = x + xOffset;
        var newY = y + yOffset;
        var newZ = z;
        var newFace = face2;
        if (newX < 0 || newX >= numX || newY < 0 || newY >= numY) {
          var xCoord = this.centerX();
          var yCoord = this.centerY();
          if (newX < 0) {
            vec3.set(vec, -0.5, yCoord, -0.5);
            newFace = adjacentFace[face2][0];
          } else if (newX >= numX) {
            vec3.set(vec, 0.5, yCoord, -0.5);
            newFace = adjacentFace[face2][1];
          } else if (newY < 0) {
            vec3.set(vec, xCoord, 0.5, -0.5);
            newFace = adjacentFace[face2][2];
          } else if (newY >= numY) {
            vec3.set(vec, xCoord, -0.5, -0.5);
            newFace = adjacentFace[face2][3];
          }
          var rot;
          rot = faceRotation[face2];
          rotateVector(vec, 0, rot.x, rot.y);
          rot = faceRotation[newFace];
          rotateVector(vec, 0, -rot.x, -rot.y);
          newX = clamp(Math.floor((0.5 + vec[0]) * numX), 0, numX - 1);
          newY = clamp(Math.floor((0.5 - vec[1]) * numY), 0, numY - 1);
        }
        result.push(new CubeTile(newFace, newX, newY, newZ, geometry));
      }
      cache.set(this, result);
      return result;
    };
    CubeTile.prototype.hash = function() {
      return hash(faceList.indexOf(this.face), this.z, this.y, this.x);
    };
    CubeTile.prototype.equals = function(that) {
      return this._geometry === that._geometry && this.face === that.face && this.z === that.z && this.y === that.y && this.x === that.x;
    };
    CubeTile.prototype.cmp = function(that) {
      return cmp(this.z, that.z) || cmp(faceList.indexOf(this.face), faceList.indexOf(that.face)) || cmp(this.y, that.y) || cmp(this.x, that.x);
    };
    CubeTile.prototype.str = function() {
      return "CubeTile(" + tile.face + ", " + tile.x + ", " + tile.y + ", " + tile.z + ")";
    };
    function CubeLevel(levelProperties) {
      this.constructor.super_.call(this, levelProperties);
      this._size = levelProperties.size;
      this._tileSize = levelProperties.tileSize;
      if (this._size % this._tileSize !== 0) {
        throw new Error("Level size is not multiple of tile size: " + this._size + " " + this._tileSize);
      }
    }
    inherits(CubeLevel, Level);
    CubeLevel.prototype.width = function() {
      return this._size;
    };
    CubeLevel.prototype.height = function() {
      return this._size;
    };
    CubeLevel.prototype.tileWidth = function() {
      return this._tileSize;
    };
    CubeLevel.prototype.tileHeight = function() {
      return this._tileSize;
    };
    CubeLevel.prototype._validateWithParentLevel = function(parentLevel) {
      var width = this.width();
      var height = this.height();
      var tileWidth = this.tileWidth();
      var tileHeight = this.tileHeight();
      var numHorizontal = this.numHorizontalTiles();
      var numVertical = this.numVerticalTiles();
      var parentWidth = parentLevel.width();
      var parentHeight = parentLevel.height();
      var parentTileWidth = parentLevel.tileWidth();
      var parentTileHeight = parentLevel.tileHeight();
      var parentNumHorizontal = parentLevel.numHorizontalTiles();
      var parentNumVertical = parentLevel.numVerticalTiles();
      if (width % parentWidth !== 0) {
        throw new Error("Level width must be multiple of parent level: " + width + " vs. " + parentWidth);
      }
      if (height % parentHeight !== 0) {
        throw new Error("Level height must be multiple of parent level: " + height + " vs. " + parentHeight);
      }
      if (numHorizontal % parentNumHorizontal !== 0) {
        throw new Error("Number of horizontal tiles must be multiple of parent level: " + numHorizontal + " (" + width + "/" + tileWidth + ") vs. " + parentNumHorizontal + " (" + parentWidth + "/" + parentTileWidth + ")");
      }
      if (numVertical % parentNumVertical !== 0) {
        throw new Error("Number of vertical tiles must be multiple of parent level: " + numVertical + " (" + height + "/" + tileHeight + ") vs. " + parentNumVertical + " (" + parentHeight + "/" + parentTileHeight + ")");
      }
    };
    function CubeGeometry(levelPropertiesList) {
      if (type(levelPropertiesList) !== "array") {
        throw new Error("Level list must be an array");
      }
      this.levelList = makeLevelList(levelPropertiesList, CubeLevel);
      this.selectableLevelList = makeSelectableLevelList(this.levelList);
      for (var i2 = 1; i2 < this.levelList.length; i2++) {
        this.levelList[i2]._validateWithParentLevel(this.levelList[i2 - 1]);
      }
      this._tileSearcher = new TileSearcher(this);
      this._neighborsCache = new LruMap(neighborsCacheSize);
      this._vec = vec4.create();
      this._viewSize = {};
    }
    CubeGeometry.prototype.maxTileSize = function() {
      var maxTileSize = 0;
      for (var i2 = 0; i2 < this.levelList.length; i2++) {
        var level = this.levelList[i2];
        maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
      }
      return maxTileSize;
    };
    CubeGeometry.prototype.levelTiles = function(level, result) {
      var levelIndex = this.levelList.indexOf(level);
      var maxX = level.numHorizontalTiles() - 1;
      var maxY = level.numVerticalTiles() - 1;
      result = result || [];
      for (var f = 0; f < faceList.length; f++) {
        var face2 = faceList[f];
        for (var x = 0; x <= maxX; x++) {
          for (var y = 0; y <= maxY; y++) {
            result.push(new CubeTile(face2, x, y, levelIndex, this));
          }
        }
      }
      return result;
    };
    CubeGeometry.prototype._closestTile = function(view, level) {
      var ray = this._vec;
      vec4.set(ray, 0, 0, 1, 1);
      vec4.transformMat4(ray, ray, view.inverseProjection());
      var minAngle = Infinity;
      var closestFace = null;
      for (var face2 in faceVectors) {
        var vector = faceVectors[face2];
        var angle3 = 1 - vec3.dot(vector, ray);
        if (angle3 < minAngle) {
          minAngle = angle3;
          closestFace = face2;
        }
      }
      var max4 = Math.max(Math.abs(ray[0]), Math.abs(ray[1]), Math.abs(ray[2])) / 0.5;
      for (var i2 = 0; i2 < 3; i2++) {
        ray[i2] = ray[i2] / max4;
      }
      var rot = faceRotation[closestFace];
      rotateVector(ray, 0, -rot.x, -rot.y);
      var tileZ = this.levelList.indexOf(level);
      var numX = level.numHorizontalTiles();
      var numY = level.numVerticalTiles();
      var tileX = clamp(Math.floor((0.5 + ray[0]) * numX), 0, numX - 1);
      var tileY = clamp(Math.floor((0.5 - ray[1]) * numY), 0, numY - 1);
      return new CubeTile(closestFace, tileX, tileY, tileZ, this);
    };
    CubeGeometry.prototype.visibleTiles = function(view, level, result) {
      var viewSize = this._viewSize;
      var tileSearcher = this._tileSearcher;
      result = result || [];
      view.size(viewSize);
      if (viewSize.width === 0 || viewSize.height === 0) {
        return result;
      }
      var startingTile = this._closestTile(view, level);
      var count = tileSearcher.search(view, startingTile, result);
      if (!count) {
        throw new Error("Starting tile is not visible");
      }
      return result;
    };
    CubeGeometry.Tile = CubeGeometry.prototype.Tile = CubeTile;
    CubeGeometry.type = CubeGeometry.prototype.type = "cube";
    CubeTile.type = CubeTile.prototype.type = "cube";
    module.exports = CubeGeometry;
  }
});

// node_modules/marzipano/src/geometries/Flat.js
var require_Flat = __commonJS({
  "node_modules/marzipano/src/geometries/Flat.js"(exports, module) {
    "use strict";
    var inherits = require_inherits();
    var hash = require_hash();
    var TileSearcher = require_TileSearcher();
    var LruMap = require_LruMap();
    var Level = require_Level();
    var makeLevelList = require_common().makeLevelList;
    var makeSelectableLevelList = require_common().makeSelectableLevelList;
    var clamp = require_clamp();
    var mod = require_mod();
    var cmp = require_cmp();
    var type = require_type();
    var vec2 = (init_esm(), __toCommonJS(esm_exports)).vec2;
    var vec4 = (init_esm(), __toCommonJS(esm_exports)).vec4;
    var neighborsCacheSize = 64;
    var neighborOffsets = [
      [0, 1],
      // top
      [1, 0],
      // right
      [0, -1],
      // bottom
      [-1, 0]
      // left
    ];
    function FlatTile(x, y, z, geometry) {
      this.x = x;
      this.y = y;
      this.z = z;
      this._geometry = geometry;
      this._level = geometry.levelList[z];
    }
    FlatTile.prototype.rotX = function() {
      return 0;
    };
    FlatTile.prototype.rotY = function() {
      return 0;
    };
    FlatTile.prototype.centerX = function() {
      var levelWidth = this._level.width();
      var tileWidth = this._level.tileWidth();
      return (this.x * tileWidth + 0.5 * this.width()) / levelWidth - 0.5;
    };
    FlatTile.prototype.centerY = function() {
      var levelHeight = this._level.height();
      var tileHeight = this._level.tileHeight();
      return 0.5 - (this.y * tileHeight + 0.5 * this.height()) / levelHeight;
    };
    FlatTile.prototype.scaleX = function() {
      var levelWidth = this._level.width();
      return this.width() / levelWidth;
    };
    FlatTile.prototype.scaleY = function() {
      var levelHeight = this._level.height();
      return this.height() / levelHeight;
    };
    FlatTile.prototype.width = function() {
      var levelWidth = this._level.width();
      var tileWidth = this._level.tileWidth();
      if (this.x === this._level.numHorizontalTiles() - 1) {
        var widthRemainder = mod(levelWidth, tileWidth);
        return widthRemainder || tileWidth;
      } else {
        return tileWidth;
      }
    };
    FlatTile.prototype.height = function() {
      var levelHeight = this._level.height();
      var tileHeight = this._level.tileHeight();
      if (this.y === this._level.numVerticalTiles() - 1) {
        var heightRemainder = mod(levelHeight, tileHeight);
        return heightRemainder || tileHeight;
      } else {
        return tileHeight;
      }
    };
    FlatTile.prototype.levelWidth = function() {
      return this._level.width();
    };
    FlatTile.prototype.levelHeight = function() {
      return this._level.height();
    };
    FlatTile.prototype.vertices = function(result) {
      if (!result) {
        result = [vec2.create(), vec2.create(), vec2.create(), vec2.create()];
      }
      var left = this.centerX() - this.scaleX() / 2;
      var right = this.centerX() + this.scaleX() / 2;
      var bottom = this.centerY() - this.scaleY() / 2;
      var top = this.centerY() + this.scaleY() / 2;
      vec2.set(result[0], left, top);
      vec2.set(result[1], right, top);
      vec2.set(result[2], right, bottom);
      vec2.set(result[3], left, bottom);
      return result;
    };
    FlatTile.prototype.parent = function() {
      if (this.z === 0) {
        return null;
      }
      var geometry = this._geometry;
      var z = this.z - 1;
      var x = Math.floor(this.x / 2);
      var y = Math.floor(this.y / 2);
      return new FlatTile(x, y, z, geometry);
    };
    FlatTile.prototype.children = function(result) {
      if (this.z === this._geometry.levelList.length - 1) {
        return null;
      }
      var geometry = this._geometry;
      var z = this.z + 1;
      result = result || [];
      result.push(new FlatTile(2 * this.x, 2 * this.y, z, geometry));
      result.push(new FlatTile(2 * this.x, 2 * this.y + 1, z, geometry));
      result.push(new FlatTile(2 * this.x + 1, 2 * this.y, z, geometry));
      result.push(new FlatTile(2 * this.x + 1, 2 * this.y + 1, z, geometry));
      return result;
    };
    FlatTile.prototype.neighbors = function() {
      var geometry = this._geometry;
      var cache = geometry._neighborsCache;
      var cachedResult = cache.get(this);
      if (cachedResult) {
        return cachedResult;
      }
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var level = this._level;
      var numX = level.numHorizontalTiles() - 1;
      var numY = level.numVerticalTiles() - 1;
      var result = [];
      for (var i = 0; i < neighborOffsets.length; i++) {
        var xOffset = neighborOffsets[i][0];
        var yOffset = neighborOffsets[i][1];
        var newX = x + xOffset;
        var newY = y + yOffset;
        var newZ = z;
        if (0 <= newX && newX <= numX && 0 <= newY && newY <= numY) {
          result.push(new FlatTile(newX, newY, newZ, geometry));
        }
      }
      cache.set(this, result);
      return result;
    };
    FlatTile.prototype.hash = function() {
      return hash(this.z, this.y, this.x);
    };
    FlatTile.prototype.equals = function(that) {
      return this._geometry === that._geometry && this.z === that.z && this.y === that.y && this.x === that.x;
    };
    FlatTile.prototype.cmp = function(that) {
      return cmp(this.z, that.z) || cmp(this.y, that.y) || cmp(this.x, that.x);
    };
    FlatTile.prototype.str = function() {
      return "FlatTile(" + tile.x + ", " + tile.y + ", " + tile.z + ")";
    };
    function FlatLevel(levelProperties) {
      this.constructor.super_.call(this, levelProperties);
      this._width = levelProperties.width;
      this._height = levelProperties.height;
      this._tileWidth = levelProperties.tileWidth;
      this._tileHeight = levelProperties.tileHeight;
    }
    inherits(FlatLevel, Level);
    FlatLevel.prototype.width = function() {
      return this._width;
    };
    FlatLevel.prototype.height = function() {
      return this._height;
    };
    FlatLevel.prototype.tileWidth = function() {
      return this._tileWidth;
    };
    FlatLevel.prototype.tileHeight = function() {
      return this._tileHeight;
    };
    FlatLevel.prototype._validateWithParentLevel = function(parentLevel) {
      var width = this.width();
      var height = this.height();
      var tileWidth = this.tileWidth();
      var tileHeight = this.tileHeight();
      var parentWidth = parentLevel.width();
      var parentHeight = parentLevel.height();
      var parentTileWidth = parentLevel.tileWidth();
      var parentTileHeight = parentLevel.tileHeight();
      if (width % parentWidth !== 0) {
        return new Error("Level width must be multiple of parent level: " + width + " vs. " + parentWidth);
      }
      if (height % parentHeight !== 0) {
        return new Error("Level height must be multiple of parent level: " + height + " vs. " + parentHeight);
      }
      if (tileWidth % parentTileWidth !== 0) {
        return new Error("Level tile width must be multiple of parent level: " + tileWidth + " vs. " + parentTileWidth);
      }
      if (tileHeight % parentTileHeight !== 0) {
        return new Error("Level tile height must be multiple of parent level: " + tileHeight + " vs. " + parentTileHeight);
      }
    };
    function FlatGeometry(levelPropertiesList) {
      if (type(levelPropertiesList) !== "array") {
        throw new Error("Level list must be an array");
      }
      this.levelList = makeLevelList(levelPropertiesList, FlatLevel);
      this.selectableLevelList = makeSelectableLevelList(this.levelList);
      for (var i = 1; i < this.levelList.length; i++) {
        this.levelList[i]._validateWithParentLevel(this.levelList[i - 1]);
      }
      this._tileSearcher = new TileSearcher(this);
      this._neighborsCache = new LruMap(neighborsCacheSize);
      this._vec = vec4.create();
      this._viewSize = {};
    }
    FlatGeometry.prototype.maxTileSize = function() {
      var maxTileSize = 0;
      for (var i = 0; i < this.levelList.length; i++) {
        var level = this.levelList[i];
        maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
      }
      return maxTileSize;
    };
    FlatGeometry.prototype.levelTiles = function(level, result) {
      var levelIndex = this.levelList.indexOf(level);
      var maxX = level.numHorizontalTiles() - 1;
      var maxY = level.numVerticalTiles() - 1;
      if (!result) {
        result = [];
      }
      for (var x = 0; x <= maxX; x++) {
        for (var y = 0; y <= maxY; y++) {
          result.push(new FlatTile(x, y, levelIndex, this));
        }
      }
      return result;
    };
    FlatGeometry.prototype._closestTile = function(view, level) {
      var ray = this._vec;
      vec4.set(ray, 0, 0, 1, 1);
      vec4.transformMat4(ray, ray, view.inverseProjection());
      var x = 0.5 + ray[0];
      var y = 0.5 - ray[1];
      var tileZ = this.levelList.indexOf(level);
      var levelWidth = level.width();
      var levelHeight = level.height();
      var tileWidth = level.tileWidth();
      var tileHeight = level.tileHeight();
      var numX = level.numHorizontalTiles();
      var numY = level.numVerticalTiles();
      var tileX = clamp(Math.floor(x * levelWidth / tileWidth), 0, numX - 1);
      var tileY = clamp(Math.floor(y * levelHeight / tileHeight), 0, numY - 1);
      return new FlatTile(tileX, tileY, tileZ, this);
    };
    FlatGeometry.prototype.visibleTiles = function(view, level, result) {
      var viewSize = this._viewSize;
      var tileSearcher = this._tileSearcher;
      result = result || [];
      view.size(viewSize);
      if (viewSize.width === 0 || viewSize.height === 0) {
        return result;
      }
      var startingTile = this._closestTile(view, level);
      var count = tileSearcher.search(view, startingTile, result);
      if (!count) {
        throw new Error("Starting tile is not visible");
      }
      return result;
    };
    FlatGeometry.Tile = FlatGeometry.prototype.Tile = FlatTile;
    FlatGeometry.type = FlatGeometry.prototype.type = "flat";
    FlatTile.type = FlatTile.prototype.type = "flat";
    module.exports = FlatGeometry;
  }
});

// node_modules/marzipano/src/geometries/Equirect.js
var require_Equirect = __commonJS({
  "node_modules/marzipano/src/geometries/Equirect.js"(exports, module) {
    "use strict";
    var inherits = require_inherits();
    var hash = require_hash();
    var cmp = require_cmp();
    var common = require_common();
    var Level = require_Level();
    var type = require_type();
    function EquirectTile(z, geometry) {
      this.z = z;
      this._geometry = geometry;
      this._level = geometry.levelList[z];
    }
    EquirectTile.prototype.rotX = function() {
      return 0;
    };
    EquirectTile.prototype.rotY = function() {
      return 0;
    };
    EquirectTile.prototype.centerX = function() {
      return 0.5;
    };
    EquirectTile.prototype.centerY = function() {
      return 0.5;
    };
    EquirectTile.prototype.scaleX = function() {
      return 1;
    };
    EquirectTile.prototype.scaleY = function() {
      return 1;
    };
    EquirectTile.prototype.parent = function() {
      if (this.z === 0) {
        return null;
      }
      return new EquirectTile(this.z - 1, this._geometry);
    };
    EquirectTile.prototype.children = function(result) {
      if (this.z === this._geometry.levelList.length - 1) {
        return null;
      }
      result = result || [];
      result.push(new EquirectTile(this.z + 1, this._geometry));
      return result;
    };
    EquirectTile.prototype.neighbors = function() {
      return [];
    };
    EquirectTile.prototype.hash = function() {
      return hash(this.z);
    };
    EquirectTile.prototype.equals = function(that) {
      return this._geometry === that._geometry && this.z === that.z;
    };
    EquirectTile.prototype.cmp = function(that) {
      return cmp(this.z, that.z);
    };
    EquirectTile.prototype.str = function() {
      return "EquirectTile(" + tile.z + ")";
    };
    function EquirectLevel(levelProperties) {
      this.constructor.super_.call(this, levelProperties);
      this._width = levelProperties.width;
    }
    inherits(EquirectLevel, Level);
    EquirectLevel.prototype.width = function() {
      return this._width;
    };
    EquirectLevel.prototype.height = function() {
      return this._width / 2;
    };
    EquirectLevel.prototype.tileWidth = function() {
      return this._width;
    };
    EquirectLevel.prototype.tileHeight = function() {
      return this._width / 2;
    };
    function EquirectGeometry(levelPropertiesList) {
      if (type(levelPropertiesList) !== "array") {
        throw new Error("Level list must be an array");
      }
      this.levelList = common.makeLevelList(levelPropertiesList, EquirectLevel);
      this.selectableLevelList = common.makeSelectableLevelList(this.levelList);
    }
    EquirectGeometry.prototype.maxTileSize = function() {
      var maxTileSize = 0;
      for (var i = 0; i < this.levelList.length; i++) {
        var level = this.levelList[i];
        maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
      }
      return maxTileSize;
    };
    EquirectGeometry.prototype.levelTiles = function(level, result) {
      var levelIndex = this.levelList.indexOf(level);
      result = result || [];
      result.push(new EquirectTile(levelIndex, this));
      return result;
    };
    EquirectGeometry.prototype.visibleTiles = function(view, level, result) {
      var tile2 = new EquirectTile(this.levelList.indexOf(level), this);
      result = result || [];
      result.length = 0;
      result.push(tile2);
    };
    EquirectGeometry.Tile = EquirectGeometry.prototype.Tile = EquirectTile;
    EquirectGeometry.type = EquirectGeometry.prototype.type = "equirect";
    EquirectTile.type = EquirectTile.prototype.type = "equirect";
    module.exports = EquirectGeometry;
  }
});

// node_modules/marzipano/src/util/convertFov.js
var require_convertFov = __commonJS({
  "node_modules/marzipano/src/util/convertFov.js"(exports, module) {
    "use strict";
    function convert(fov, fromDimension, toDimension) {
      return 2 * Math.atan(toDimension * Math.tan(fov / 2) / fromDimension);
    }
    function htov(fov, width, height) {
      return convert(fov, width, height);
    }
    function htod(fov, width, height) {
      return convert(fov, width, Math.sqrt(width * width + height * height));
    }
    function vtoh(fov, width, height) {
      return convert(fov, height, width);
    }
    function vtod(fov, width, height) {
      return convert(fov, height, Math.sqrt(width * width + height * height));
    }
    function dtoh(fov, width, height) {
      return convert(fov, Math.sqrt(width * width + height * height), width);
    }
    function dtov(fov, width, height) {
      return convert(fov, Math.sqrt(width * width + height * height), height);
    }
    module.exports = {
      convert,
      htov,
      htod,
      vtoh,
      vtod,
      dtoh,
      dtov
    };
  }
});

// node_modules/marzipano/src/util/real.js
var require_real = __commonJS({
  "node_modules/marzipano/src/util/real.js"(exports, module) {
    "use strict";
    function real(x) {
      return typeof x === "number" && isFinite(x);
    }
    module.exports = real;
  }
});

// node_modules/marzipano/src/util/decimal.js
var require_decimal = __commonJS({
  "node_modules/marzipano/src/util/decimal.js"(exports, module) {
    "use strict";
    function decimal(x) {
      return x.toPrecision(15);
    }
    module.exports = decimal;
  }
});

// node_modules/marzipano/src/util/compose.js
var require_compose = __commonJS({
  "node_modules/marzipano/src/util/compose.js"(exports, module) {
    "use strict";
    function compose() {
      var fnList = arguments;
      return function composed(initialArg) {
        var ret = initialArg;
        for (var i = 0; i < fnList.length; i++) {
          var fn = fnList[i];
          ret = fn.call(null, ret);
        }
        return ret;
      };
    }
    module.exports = compose;
  }
});

// node_modules/marzipano/src/views/Rectilinear.js
var require_Rectilinear = __commonJS({
  "node_modules/marzipano/src/views/Rectilinear.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var mat4 = (init_esm(), __toCommonJS(esm_exports)).mat4;
    var vec4 = (init_esm(), __toCommonJS(esm_exports)).vec4;
    var pixelRatio = require_pixelRatio();
    var convertFov = require_convertFov();
    var mod = require_mod();
    var real = require_real();
    var clamp = require_clamp();
    var decimal = require_decimal();
    var compose = require_compose();
    var clearOwnProperties = require_clearOwnProperties();
    var defaultWidth = 0;
    var defaultHeight = 0;
    var defaultYaw = 0;
    var defaultPitch = 0;
    var defaultRoll = 0;
    var defaultFov = Math.PI / 4;
    var defaultProjectionCenterX = 0;
    var defaultProjectionCenterY = 0;
    var fovLimitEpsilon = 1e-6;
    function RectilinearView(params, limiter) {
      this._yaw = params && params.yaw != null ? params.yaw : defaultYaw;
      this._pitch = params && params.pitch != null ? params.pitch : defaultPitch;
      this._roll = params && params.roll != null ? params.roll : defaultRoll;
      this._fov = params && params.fov != null ? params.fov : defaultFov;
      this._width = params && params.width != null ? params.width : defaultWidth;
      this._height = params && params.height != null ? params.height : defaultHeight;
      this._projectionCenterX = params && params.projectionCenterX != null ? params.projectionCenterX : defaultProjectionCenterX;
      this._projectionCenterY = params && params.projectionCenterY != null ? params.projectionCenterY : defaultProjectionCenterY;
      this._limiter = limiter || null;
      this._projMatrix = mat4.create();
      this._invProjMatrix = mat4.create();
      this._frustum = [
        vec4.create(),
        // left
        vec4.create(),
        // right
        vec4.create(),
        // bottom
        vec4.create(),
        // top
        vec4.create()
        // camera
      ];
      this._projectionChanged = true;
      this._params = {};
      this._fovs = {};
      this._tmpVec = vec4.create();
      this._update();
    }
    eventEmitter(RectilinearView);
    RectilinearView.prototype.destroy = function() {
      clearOwnProperties(this);
    };
    RectilinearView.prototype.yaw = function() {
      return this._yaw;
    };
    RectilinearView.prototype.pitch = function() {
      return this._pitch;
    };
    RectilinearView.prototype.roll = function() {
      return this._roll;
    };
    RectilinearView.prototype.projectionCenterX = function() {
      return this._projectionCenterX;
    };
    RectilinearView.prototype.projectionCenterY = function() {
      return this._projectionCenterY;
    };
    RectilinearView.prototype.fov = function() {
      return this._fov;
    };
    RectilinearView.prototype.width = function() {
      return this._width;
    };
    RectilinearView.prototype.height = function() {
      return this._height;
    };
    RectilinearView.prototype.size = function(size) {
      size = size || {};
      size.width = this._width;
      size.height = this._height;
      return size;
    };
    RectilinearView.prototype.parameters = function(params) {
      params = params || {};
      params.yaw = this._yaw;
      params.pitch = this._pitch;
      params.roll = this._roll;
      params.fov = this._fov;
      return params;
    };
    RectilinearView.prototype.limiter = function() {
      return this._limiter;
    };
    RectilinearView.prototype.setYaw = function(yaw) {
      this._resetParams();
      this._params.yaw = yaw;
      this._update(this._params);
    };
    RectilinearView.prototype.setPitch = function(pitch) {
      this._resetParams();
      this._params.pitch = pitch;
      this._update(this._params);
    };
    RectilinearView.prototype.setRoll = function(roll) {
      this._resetParams();
      this._params.roll = roll;
      this._update(this._params);
    };
    RectilinearView.prototype.setFov = function(fov) {
      this._resetParams();
      this._params.fov = fov;
      this._update(this._params);
    };
    RectilinearView.prototype.setProjectionCenterX = function(projectionCenterX) {
      this._resetParams();
      this._params.projectionCenterX = projectionCenterX;
      this._update(this._params);
    };
    RectilinearView.prototype.setProjectionCenterY = function(projectionCenterY) {
      this._resetParams();
      this._params.projectionCenterY = projectionCenterY;
      this._update(this._params);
    };
    RectilinearView.prototype.offsetYaw = function(yawOffset) {
      this.setYaw(this._yaw + yawOffset);
    };
    RectilinearView.prototype.offsetPitch = function(pitchOffset) {
      this.setPitch(this._pitch + pitchOffset);
    };
    RectilinearView.prototype.offsetRoll = function(rollOffset) {
      this.setRoll(this._roll + rollOffset);
    };
    RectilinearView.prototype.offsetFov = function(fovOffset) {
      this.setFov(this._fov + fovOffset);
    };
    RectilinearView.prototype.setSize = function(size) {
      this._resetParams();
      this._params.width = size.width;
      this._params.height = size.height;
      this._update(this._params);
    };
    RectilinearView.prototype.setParameters = function(params) {
      this._resetParams();
      this._params.yaw = params.yaw;
      this._params.pitch = params.pitch;
      this._params.roll = params.roll;
      this._params.fov = params.fov;
      this._params.projectionCenterX = params.projectionCenterX;
      this._params.projectionCenterY = params.projectionCenterY;
      this._update(this._params);
    };
    RectilinearView.prototype.setLimiter = function(limiter) {
      this._limiter = limiter || null;
      this._update();
    };
    RectilinearView.prototype._resetParams = function() {
      var params = this._params;
      params.yaw = null;
      params.pitch = null;
      params.roll = null;
      params.fov = null;
      params.width = null;
      params.height = null;
    };
    RectilinearView.prototype._update = function(params) {
      if (params == null) {
        this._resetParams();
        params = this._params;
      }
      var oldYaw = this._yaw;
      var oldPitch = this._pitch;
      var oldRoll = this._roll;
      var oldFov = this._fov;
      var oldProjectionCenterX = this._projectionCenterX;
      var oldProjectionCenterY = this._projectionCenterY;
      var oldWidth = this._width;
      var oldHeight = this._height;
      params.yaw = params.yaw != null ? params.yaw : oldYaw;
      params.pitch = params.pitch != null ? params.pitch : oldPitch;
      params.roll = params.roll != null ? params.roll : oldRoll;
      params.fov = params.fov != null ? params.fov : oldFov;
      params.width = params.width != null ? params.width : oldWidth;
      params.height = params.height != null ? params.height : oldHeight;
      params.projectionCenterX = params.projectionCenterX != null ? params.projectionCenterX : oldProjectionCenterX;
      params.projectionCenterY = params.projectionCenterY != null ? params.projectionCenterY : oldProjectionCenterY;
      if (this._limiter) {
        params = this._limiter(params);
        if (!params) {
          throw new Error("Bad view limiter");
        }
      }
      params = this._normalize(params);
      var newYaw = params.yaw;
      var newPitch = params.pitch;
      var newRoll = params.roll;
      var newFov = params.fov;
      var newWidth = params.width;
      var newHeight = params.height;
      var newProjectionCenterX = params.projectionCenterX;
      var newProjectionCenterY = params.projectionCenterY;
      if (!real(newYaw) || !real(newPitch) || !real(newRoll) || !real(newFov) || !real(newWidth) || !real(newHeight) || !real(newProjectionCenterX) || !real(newProjectionCenterY)) {
        throw new Error("Bad view - suspect a broken limiter");
      }
      this._yaw = newYaw;
      this._pitch = newPitch;
      this._roll = newRoll;
      this._fov = newFov;
      this._width = newWidth;
      this._height = newHeight;
      this._projectionCenterX = newProjectionCenterX;
      this._projectionCenterY = newProjectionCenterY;
      if (newYaw !== oldYaw || newPitch !== oldPitch || newRoll !== oldRoll || newFov !== oldFov || newWidth !== oldWidth || newHeight !== oldHeight || newProjectionCenterX !== oldProjectionCenterX || newProjectionCenterY !== oldProjectionCenterY) {
        this._projectionChanged = true;
        this.emit("change");
      }
      if (newWidth !== oldWidth || newHeight !== oldHeight) {
        this.emit("resize");
      }
    };
    RectilinearView.prototype._normalize = function(params) {
      this._normalizeCoordinates(params);
      var hfovPi = convertFov.htov(Math.PI, params.width, params.height);
      var maxFov = isNaN(hfovPi) ? Math.PI : Math.min(Math.PI, hfovPi);
      params.fov = clamp(params.fov, fovLimitEpsilon, maxFov - fovLimitEpsilon);
      return params;
    };
    RectilinearView.prototype._normalizeCoordinates = function(params) {
      if ("yaw" in params) {
        params.yaw = mod(params.yaw - Math.PI, -2 * Math.PI) + Math.PI;
      }
      if ("pitch" in params) {
        params.pitch = mod(params.pitch - Math.PI, -2 * Math.PI) + Math.PI;
      }
      if ("roll" in params) {
        params.roll = mod(params.roll - Math.PI, -2 * Math.PI) + Math.PI;
      }
      return params;
    };
    RectilinearView.prototype.normalizeToClosest = function(coords, result) {
      var viewYaw = this._yaw;
      var viewPitch = this._pitch;
      var coordYaw = coords.yaw;
      var coordPitch = coords.pitch;
      var prevYaw = coordYaw - 2 * Math.PI;
      var nextYaw = coordYaw + 2 * Math.PI;
      if (Math.abs(prevYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
        coordYaw = prevYaw;
      } else if (Math.abs(nextYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
        coordYaw = nextYaw;
      }
      var prevPitch = coordPitch - 2 * Math.PI;
      var nextPitch = coordPitch + 2 * Math.PI;
      if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
        coordPitch = prevPitch;
      } else if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
        coordPitch = nextPitch;
      }
      result = result || {};
      result.yaw = coordYaw;
      result.pitch = coordPitch;
      return result;
    };
    RectilinearView.prototype.updateWithControlParameters = function(parameters) {
      var vfov = this._fov;
      var hfov = convertFov.vtoh(vfov, this._width, this._height);
      if (isNaN(hfov)) {
        hfov = vfov;
      }
      this.offsetYaw(parameters.axisScaledX * hfov + parameters.x * 2 * hfov + parameters.yaw);
      this.offsetPitch(parameters.axisScaledY * vfov + parameters.y * 2 * hfov + parameters.pitch);
      this.offsetRoll(-parameters.roll);
      this.offsetFov(parameters.zoom * vfov);
    };
    RectilinearView.prototype._updateProjection = function() {
      var projMatrix = this._projMatrix;
      var invProjMatrix = this._invProjMatrix;
      var frustum2 = this._frustum;
      if (this._projectionChanged) {
        var width = this._width;
        var height = this._height;
        var vfov = this._fov;
        var hfov = convertFov.vtoh(vfov, width, height);
        var aspect = width / height;
        var projectionCenterX = this._projectionCenterX;
        var projectionCenterY = this._projectionCenterY;
        if (projectionCenterX !== 0 || projectionCenterY !== 0) {
          var offsetAngleX = Math.atan(projectionCenterX * 2 * Math.tan(hfov / 2));
          var offsetAngleY = Math.atan(projectionCenterY * 2 * Math.tan(vfov / 2));
          var fovs = this._fovs;
          fovs.leftDegrees = (hfov / 2 + offsetAngleX) * 180 / Math.PI;
          fovs.rightDegrees = (hfov / 2 - offsetAngleX) * 180 / Math.PI;
          fovs.upDegrees = (vfov / 2 + offsetAngleY) * 180 / Math.PI;
          fovs.downDegrees = (vfov / 2 - offsetAngleY) * 180 / Math.PI;
          mat4.perspectiveFromFieldOfView(projMatrix, fovs, -1, 1);
        } else {
          mat4.perspective(projMatrix, vfov, aspect, -1, 1);
        }
        mat4.rotateZ(projMatrix, projMatrix, this._roll);
        mat4.rotateX(projMatrix, projMatrix, this._pitch);
        mat4.rotateY(projMatrix, projMatrix, this._yaw);
        mat4.invert(invProjMatrix, projMatrix);
        this._matrixToFrustum(projMatrix, frustum2);
        this._projectionChanged = false;
      }
    };
    RectilinearView.prototype._matrixToFrustum = function(p, f) {
      vec4.set(f[0], p[3] + p[0], p[7] + p[4], p[11] + p[8], 0);
      vec4.set(f[1], p[3] - p[0], p[7] - p[4], p[11] - p[8], 0);
      vec4.set(f[2], p[3] + p[1], p[7] + p[5], p[11] + p[9], 0);
      vec4.set(f[3], p[3] - p[1], p[7] - p[5], p[11] - p[9], 0);
      vec4.set(f[4], p[3] + p[2], p[7] + p[6], p[11] + p[10], 0);
    };
    RectilinearView.prototype.projection = function() {
      this._updateProjection();
      return this._projMatrix;
    };
    RectilinearView.prototype.inverseProjection = function() {
      this._updateProjection();
      return this._invProjMatrix;
    };
    RectilinearView.prototype.intersects = function(rectangle) {
      this._updateProjection();
      var frustum2 = this._frustum;
      var vertex = this._tmpVec;
      for (var i = 0; i < frustum2.length; i++) {
        var plane = frustum2[i];
        var inside = false;
        for (var j = 0; j < rectangle.length; j++) {
          var corner = rectangle[j];
          vec4.set(vertex, corner[0], corner[1], corner[2], 0);
          if (vec4.dot(plane, vertex) >= 0) {
            inside = true;
          }
        }
        if (!inside) {
          return false;
        }
      }
      return true;
    };
    RectilinearView.prototype.selectLevel = function(levelList) {
      var requiredPixels = pixelRatio() * this._height;
      var coverFactor = Math.tan(0.5 * this._fov);
      for (var i = 0; i < levelList.length; i++) {
        var level = levelList[i];
        if (coverFactor * level.height() >= requiredPixels) {
          return level;
        }
      }
      return levelList[levelList.length - 1];
    };
    RectilinearView.prototype.coordinatesToScreen = function(coords, result) {
      var ray = this._tmpVec;
      if (!result) {
        result = {};
      }
      var width = this._width;
      var height = this._height;
      if (width <= 0 || height <= 0) {
        result.x = null;
        result.y = null;
        return null;
      }
      var yaw = coords.yaw;
      var pitch = coords.pitch;
      var x = Math.sin(yaw) * Math.cos(pitch);
      var y = -Math.sin(pitch);
      var z = -Math.cos(yaw) * Math.cos(pitch);
      vec4.set(ray, x, y, z, 1);
      vec4.transformMat4(ray, ray, this.projection());
      if (ray[3] >= 0) {
        result.x = width * (ray[0] / ray[3] + 1) / 2;
        result.y = height * (1 - ray[1] / ray[3]) / 2;
      } else {
        result.x = null;
        result.y = null;
        return null;
      }
      return result;
    };
    RectilinearView.prototype.screenToCoordinates = function(coords, result) {
      var ray = this._tmpVec;
      if (!result) {
        result = {};
      }
      var width = this._width;
      var height = this._height;
      var vecx = 2 * coords.x / width - 1;
      var vecy = 1 - 2 * coords.y / height;
      vec4.set(ray, vecx, vecy, 1, 1);
      vec4.transformMat4(ray, ray, this.inverseProjection());
      var r = Math.sqrt(ray[0] * ray[0] + ray[1] * ray[1] + ray[2] * ray[2]);
      result.yaw = Math.atan2(ray[0], -ray[2]);
      result.pitch = Math.acos(ray[1] / r) - Math.PI / 2;
      this._normalizeCoordinates(result);
      return result;
    };
    RectilinearView.prototype.coordinatesToPerspectiveTransform = function(coords, radius, extraTransforms) {
      extraTransforms = extraTransforms || "";
      var height = this._height;
      var width = this._width;
      var fov = this._fov;
      var perspective2 = 0.5 * height / Math.tan(fov / 2);
      var transform = "";
      transform += "translateX(" + decimal(width / 2) + "px) ";
      transform += "translateY(" + decimal(height / 2) + "px) ";
      transform += "translateX(-50%) translateY(-50%) ";
      transform += "perspective(" + decimal(perspective2) + "px) ";
      transform += "translateZ(" + decimal(perspective2) + "px) ";
      transform += "rotateZ(" + decimal(-this._roll) + "rad) ";
      transform += "rotateX(" + decimal(-this._pitch) + "rad) ";
      transform += "rotateY(" + decimal(this._yaw) + "rad) ";
      transform += "rotateY(" + decimal(-coords.yaw) + "rad) ";
      transform += "rotateX(" + decimal(coords.pitch) + "rad) ";
      transform += "translateZ(" + decimal(-radius) + "px) ";
      transform += extraTransforms + " ";
      return transform;
    };
    RectilinearView.limit = {
      /**
       * Returns a view limiter that constrains the yaw angle.
       * @param {number} min The minimum yaw value.
       * @param {number} max The maximum yaw value.
       * @return {RectilinearViewLimiter}
       */
      yaw: function(min4, max4) {
        return function limitYaw(params) {
          params.yaw = clamp(params.yaw, min4, max4);
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the pitch angle.
       * @param {number} min The minimum pitch value.
       * @param {number} max The maximum pitch value.
       * @return {RectilinearViewLimiter}
       */
      pitch: function(min4, max4) {
        return function limitPitch(params) {
          params.pitch = clamp(params.pitch, min4, max4);
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the roll angle.
       * @param {number} min The minimum roll value.
       * @param {number} max The maximum roll value.
       * @return {RectilinearViewLimiter}
       */
      roll: function(min4, max4) {
        return function limitRoll(params) {
          params.roll = clamp(params.roll, min4, max4);
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the horizontal field of view.
       * @param {number} min The minimum horizontal field of view.
       * @param {number} max The maximum horizontal field of view.
       * @return {RectilinearViewLimiter}
       */
      hfov: function(min4, max4) {
        return function limitHfov(params) {
          var width = params.width;
          var height = params.height;
          if (width > 0 && height > 0) {
            var vmin = convertFov.htov(min4, width, height);
            var vmax = convertFov.htov(max4, width, height);
            params.fov = clamp(params.fov, vmin, vmax);
          }
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the vertical field of view.
       * @param {number} min The minimum vertical field of view.
       * @param {number} max The maximum vertical field of view.
       * @return {RectilinearViewLimiter}
       */
      vfov: function(min4, max4) {
        return function limitVfov(params) {
          params.fov = clamp(params.fov, min4, max4);
          return params;
        };
      },
      /**
       * Returns a view limiter that prevents zooming in beyond the given
       * resolution.
       * @param {number} size The cube face width in pixels or, equivalently, one
       *     fourth of the equirectangular width in pixels.
       * @return {RectilinearViewLimiter}
       */
      resolution: function(size) {
        return function limitResolution(params) {
          var height = params.height;
          if (height) {
            var requiredPixels = pixelRatio() * height;
            var minFov = 2 * Math.atan(requiredPixels / size);
            params.fov = clamp(params.fov, minFov, Infinity);
          }
          return params;
        };
      },
      /**
       * Returns a view limiter that limits the horizontal and vertical field of
       * view, prevents zooming in past the image resolution, and limits the pitch
       * range to prevent the camera wrapping around at the poles. These are the
       * most common view constraints for a 360 panorama.
       * @param {number} maxResolution The cube face width in pixels or,
       *     equivalently, one fourth of the equirectangular width in pixels.
       * @param {number} maxVFov The maximum vertical field of view.
       * @param {number} [maxHFov=maxVFov] The maximum horizontal field of view.
       * @return {RectilinearViewLimiter}
       */
      traditional: function(maxResolution, maxVFov, maxHFov) {
        maxHFov = maxHFov != null ? maxHFov : maxVFov;
        return compose(
          RectilinearView.limit.resolution(maxResolution),
          RectilinearView.limit.vfov(0, maxVFov),
          RectilinearView.limit.hfov(0, maxHFov),
          RectilinearView.limit.pitch(-Math.PI / 2, Math.PI / 2)
        );
      }
    };
    RectilinearView.type = RectilinearView.prototype.type = "rectilinear";
    module.exports = RectilinearView;
  }
});

// node_modules/marzipano/src/views/Flat.js
var require_Flat2 = __commonJS({
  "node_modules/marzipano/src/views/Flat.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var mat4 = (init_esm(), __toCommonJS(esm_exports)).mat4;
    var vec4 = (init_esm(), __toCommonJS(esm_exports)).vec4;
    var pixelRatio = require_pixelRatio();
    var real = require_real();
    var clamp = require_clamp();
    var clearOwnProperties = require_clearOwnProperties();
    var defaultWidth = 0;
    var defaultHeight = 0;
    var defaultX = 0.5;
    var defaultY = 0.5;
    var defaultZoom = 1;
    var planeAxes = [
      1,
      // top
      0,
      // right
      1,
      // bottom
      0
      // left
    ];
    var planeCmp = [
      -1,
      // top
      -1,
      // right
      1,
      // bottom
      1
      // left
    ];
    var zoomLimitEpsilon = 1e-6;
    function FlatView(params, limiter) {
      if (!(params && params.mediaAspectRatio != null)) {
        throw new Error("mediaAspectRatio must be defined");
      }
      this._x = params && params.x != null ? params.x : defaultX;
      this._y = params && params.y != null ? params.y : defaultY;
      this._zoom = params && params.zoom != null ? params.zoom : defaultZoom;
      this._mediaAspectRatio = params.mediaAspectRatio;
      this._width = params && params.width != null ? params.width : defaultWidth;
      this._height = params && params.height != null ? params.height : defaultHeight;
      this._limiter = limiter || null;
      this._projMatrix = mat4.create();
      this._invProjMatrix = mat4.create();
      this._frustum = [
        0,
        // top
        0,
        // right
        0,
        // bottom
        0
        // left
      ];
      this._projectionChanged = true;
      this._params = {};
      this._vec = vec4.create();
      this._update();
    }
    eventEmitter(FlatView);
    FlatView.prototype.destroy = function() {
      clearOwnProperties(this);
    };
    FlatView.prototype.x = function() {
      return this._x;
    };
    FlatView.prototype.y = function() {
      return this._y;
    };
    FlatView.prototype.zoom = function() {
      return this._zoom;
    };
    FlatView.prototype.mediaAspectRatio = function() {
      return this._mediaAspectRatio;
    };
    FlatView.prototype.width = function() {
      return this._width;
    };
    FlatView.prototype.height = function() {
      return this._height;
    };
    FlatView.prototype.size = function(size) {
      size = size || {};
      size.width = this._width;
      size.height = this._height;
      return size;
    };
    FlatView.prototype.parameters = function(params) {
      params = params || {};
      params.x = this._x;
      params.y = this._y;
      params.zoom = this._zoom;
      params.mediaAspectRatio = this._mediaAspectRatio;
      return params;
    };
    FlatView.prototype.limiter = function() {
      return this._limiter;
    };
    FlatView.prototype.setX = function(x) {
      this._resetParams();
      this._params.x = x;
      this._update(this._params);
    };
    FlatView.prototype.setY = function(y) {
      this._resetParams();
      this._params.y = y;
      this._update(this._params);
    };
    FlatView.prototype.setZoom = function(zoom) {
      this._resetParams();
      this._params.zoom = zoom;
      this._update(this._params);
    };
    FlatView.prototype.offsetX = function(xOffset) {
      this.setX(this._x + xOffset);
    };
    FlatView.prototype.offsetY = function(yOffset) {
      this.setY(this._y + yOffset);
    };
    FlatView.prototype.offsetZoom = function(zoomOffset) {
      this.setZoom(this._zoom + zoomOffset);
    };
    FlatView.prototype.setMediaAspectRatio = function(mediaAspectRatio) {
      this._resetParams();
      this._params.mediaAspectRatio = mediaAspectRatio;
      this._update(this._params);
    };
    FlatView.prototype.setSize = function(size) {
      this._resetParams();
      this._params.width = size.width;
      this._params.height = size.height;
      this._update(this._params);
    };
    FlatView.prototype.setParameters = function(params) {
      this._resetParams();
      this._params.x = params.x;
      this._params.y = params.y;
      this._params.zoom = params.zoom;
      this._params.mediaAspectRatio = params.mediaAspectRatio;
      this._update(this._params);
    };
    FlatView.prototype.setLimiter = function(limiter) {
      this._limiter = limiter || null;
      this._update();
    };
    FlatView.prototype._resetParams = function() {
      var params = this._params;
      params.x = null;
      params.y = null;
      params.zoom = null;
      params.mediaAspectRatio = null;
      params.width = null;
      params.height = null;
    };
    FlatView.prototype._update = function(params) {
      if (params == null) {
        this._resetParams();
        params = this._params;
      }
      var oldX = this._x;
      var oldY = this._y;
      var oldZoom = this._zoom;
      var oldMediaAspectRatio = this._mediaAspectRatio;
      var oldWidth = this._width;
      var oldHeight = this._height;
      params.x = params.x != null ? params.x : oldX;
      params.y = params.y != null ? params.y : oldY;
      params.zoom = params.zoom != null ? params.zoom : oldZoom;
      params.mediaAspectRatio = params.mediaAspectRatio != null ? params.mediaAspectRatio : oldMediaAspectRatio;
      params.width = params.width != null ? params.width : oldWidth;
      params.height = params.height != null ? params.height : oldHeight;
      if (this._limiter) {
        params = this._limiter(params);
        if (!params) {
          throw new Error("Bad view limiter");
        }
      }
      var newX = params.x;
      var newY = params.y;
      var newZoom = params.zoom;
      var newMediaAspectRatio = params.mediaAspectRatio;
      var newWidth = params.width;
      var newHeight = params.height;
      if (!real(newX) || !real(newY) || !real(newZoom) || !real(newMediaAspectRatio) || !real(newWidth) || !real(newHeight)) {
        throw new Error("Bad view - suspect a broken limiter");
      }
      newZoom = clamp(newZoom, zoomLimitEpsilon, Infinity);
      this._x = newX;
      this._y = newY;
      this._zoom = newZoom;
      this._mediaAspectRatio = newMediaAspectRatio;
      this._width = newWidth;
      this._height = newHeight;
      if (newX !== oldX || newY !== oldY || newZoom !== oldZoom || newMediaAspectRatio !== oldMediaAspectRatio || newWidth !== oldWidth || newHeight !== oldHeight) {
        this._projectionChanged = true;
        this.emit("change");
      }
      if (newWidth !== oldWidth || newHeight !== oldHeight) {
        this.emit("resize");
      }
    };
    FlatView.prototype._zoomX = function() {
      return this._zoom;
    };
    FlatView.prototype._zoomY = function() {
      var mediaAspectRatio = this._mediaAspectRatio;
      var aspect = this._width / this._height;
      var zoomX = this._zoom;
      var zoomY = zoomX * mediaAspectRatio / aspect;
      if (isNaN(zoomY)) {
        zoomY = zoomX;
      }
      return zoomY;
    };
    FlatView.prototype.updateWithControlParameters = function(parameters) {
      var scale10 = this.zoom();
      var zoomX = this._zoomX();
      var zoomY = this._zoomY();
      this.offsetX(parameters.axisScaledX * zoomX + parameters.x * scale10);
      this.offsetY(parameters.axisScaledY * zoomY + parameters.y * scale10);
      this.offsetZoom(parameters.zoom * scale10);
    };
    FlatView.prototype._updateProjection = function() {
      var projMatrix = this._projMatrix;
      var invProjMatrix = this._invProjMatrix;
      var frustum2 = this._frustum;
      if (this._projectionChanged) {
        var x = this._x;
        var y = this._y;
        var zoomX = this._zoomX();
        var zoomY = this._zoomY();
        var top = frustum2[0] = 0.5 - y + 0.5 * zoomY;
        var right = frustum2[1] = x - 0.5 + 0.5 * zoomX;
        var bottom = frustum2[2] = 0.5 - y - 0.5 * zoomY;
        var left = frustum2[3] = x - 0.5 - 0.5 * zoomX;
        mat4.ortho(projMatrix, left, right, bottom, top, -1, 1);
        mat4.invert(invProjMatrix, projMatrix);
        this._projectionChanged = false;
      }
    };
    FlatView.prototype.projection = function() {
      this._updateProjection();
      return this._projMatrix;
    };
    FlatView.prototype.inverseProjection = function() {
      this._updateProjection();
      return this._invProjMatrix;
    };
    FlatView.prototype.intersects = function(rectangle) {
      this._updateProjection();
      var frustum2 = this._frustum;
      for (var i = 0; i < frustum2.length; i++) {
        var limit = frustum2[i];
        var axis = planeAxes[i];
        var cmp = planeCmp[i];
        var inside = false;
        for (var j = 0; j < rectangle.length; j++) {
          var vertex = rectangle[j];
          if (cmp < 0 && vertex[axis] < limit || cmp > 0 && vertex[axis] > limit) {
            inside = true;
            break;
          }
        }
        if (!inside) {
          return false;
        }
      }
      return true;
    };
    FlatView.prototype.selectLevel = function(levels) {
      var requiredPixels = pixelRatio() * this.width();
      var zoomFactor = this._zoom;
      for (var i = 0; i < levels.length; i++) {
        var level = levels[i];
        if (zoomFactor * level.width() >= requiredPixels) {
          return level;
        }
      }
      return levels[levels.length - 1];
    };
    FlatView.prototype.coordinatesToScreen = function(coords, result) {
      var ray = this._vec;
      if (!result) {
        result = {};
      }
      var width = this._width;
      var height = this._height;
      if (width <= 0 || height <= 0) {
        result.x = null;
        result.y = null;
        return null;
      }
      var x = coords && coords.x != null ? coords.x : defaultX;
      var y = coords && coords.y != null ? coords.y : defaultY;
      vec4.set(ray, x - 0.5, 0.5 - y, -1, 1);
      vec4.transformMat4(ray, ray, this.projection());
      for (var i = 0; i < 3; i++) {
        ray[i] /= ray[3];
      }
      result.x = width * (ray[0] + 1) / 2;
      result.y = height * (1 - ray[1]) / 2;
      return result;
    };
    FlatView.prototype.screenToCoordinates = function(coords, result) {
      var ray = this._vec;
      if (!result) {
        result = {};
      }
      var width = this._width;
      var height = this._height;
      var vecx = 2 * coords.x / width - 1;
      var vecy = 1 - 2 * coords.y / height;
      vec4.set(ray, vecx, vecy, 1, 1);
      vec4.transformMat4(ray, ray, this.inverseProjection());
      result.x = 0.5 + ray[0];
      result.y = 0.5 - ray[1];
      return result;
    };
    FlatView.limit = {
      /**
       * Returns a view limiter that constrains the x parameter.
       * @param {number} min The minimum x value.
       * @param {number} max The maximum y value.
       * @return {FlatViewLimiter}
       */
      x: function(min4, max4) {
        return function limitX(params) {
          params.x = clamp(params.x, min4, max4);
          return params;
        };
      },
      /**
       * Return a view limiter that constrains the y parameter.
       * @param {number} min The minimum y value.
       * @param {number} max The maximum y value.
       * @return {FlatViewLimiter}
       */
      y: function(min4, max4) {
        return function limitY(params) {
          params.y = clamp(params.y, min4, max4);
          return params;
        };
      },
      /**
       * Returns a view limiter than constrains the zoom parameter.
       * @param {number} min The minimum zoom value.
       * @param {number} max The maximum zoom value.
       * @return {FlatViewLimiter}
       */
      zoom: function(min4, max4) {
        return function limitZoom(params) {
          params.zoom = clamp(params.zoom, min4, max4);
          return params;
        };
      },
      /**
       * Returns a view limiter that prevents zooming in beyond the given
       * resolution.
       * @param {number} size The image width in pixels.
       * @return {FlatViewLimiter}
       */
      resolution: function(size) {
        return function limitResolution(params) {
          if (params.width <= 0 || params.height <= 0) {
            return params;
          }
          var width = params.width;
          var minZoom = pixelRatio() * width / size;
          params.zoom = clamp(params.zoom, minZoom, Infinity);
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the values of the x parameter that
       * are inside the viewport.
       * @param {number} min The minimum x value.
       * @param {number} max The maximum x value.
       * @return {FlatViewLimiter}
       */
      visibleX: function(min4, max4) {
        return function limitVisibleX(params) {
          var maxZoom = max4 - min4;
          if (params.zoom > maxZoom) {
            params.zoom = maxZoom;
          }
          var minX = min4 + 0.5 * params.zoom;
          var maxX = max4 - 0.5 * params.zoom;
          params.x = clamp(params.x, minX, maxX);
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the values of the y parameter that
       * are inside the viewport.
       * @param {number} min The minimum y value.
       * @param {number} max The maximum y value.
       * @return {FlatViewLimiter}
       */
      visibleY: function(min4, max4) {
        return function limitVisibleY(params) {
          if (params.width <= 0 || params.height <= 0) {
            return params;
          }
          var viewportAspectRatio = params.width / params.height;
          var factor = viewportAspectRatio / params.mediaAspectRatio;
          var maxZoom = (max4 - min4) * factor;
          if (params.zoom > maxZoom) {
            params.zoom = maxZoom;
          }
          var minY = min4 + 0.5 * params.zoom / factor;
          var maxY = max4 - 0.5 * params.zoom / factor;
          params.y = clamp(params.y, minY, maxY);
          return params;
        };
      },
      /**
       * Returns a view limiter that constrains the zoom parameter such that
       * zooming out is prevented beyond the point at which the image is fully
       * visible. Unless the image and the viewport have the same aspect ratio,
       * this will cause bands to appear around the image.
       * @return {FlatViewLimiter}
       */
      letterbox: function() {
        return function limitLetterbox(params) {
          if (params.width <= 0 || params.height <= 0) {
            return params;
          }
          var viewportAspectRatio = params.width / params.height;
          var fullWidthZoom = 1;
          var fullHeightZoom = viewportAspectRatio / params.mediaAspectRatio;
          if (params.mediaAspectRatio >= viewportAspectRatio) {
            params.zoom = Math.min(params.zoom, fullWidthZoom);
          }
          if (params.mediaAspectRatio <= viewportAspectRatio) {
            params.zoom = Math.min(params.zoom, fullHeightZoom);
          }
          var minX, maxX;
          if (params.zoom > fullWidthZoom) {
            minX = maxX = 0.5;
          } else {
            minX = 0 + 0.5 * params.zoom / fullWidthZoom;
            maxX = 1 - 0.5 * params.zoom / fullWidthZoom;
          }
          var minY, maxY;
          if (params.zoom > fullHeightZoom) {
            minY = maxY = 0.5;
          } else {
            minY = 0 + 0.5 * params.zoom / fullHeightZoom;
            maxY = 1 - 0.5 * params.zoom / fullHeightZoom;
          }
          params.x = clamp(params.x, minX, maxX);
          params.y = clamp(params.y, minY, maxY);
          return params;
        };
      }
    };
    FlatView.type = FlatView.prototype.type = "flat";
    module.exports = FlatView;
  }
});

// node_modules/marzipano/src/collections/WorkPool.js
var require_WorkPool = __commonJS({
  "node_modules/marzipano/src/collections/WorkPool.js"(exports, module) {
    "use strict";
    var WorkQueue = require_WorkQueue();
    var mod = require_mod();
    function WorkPool(opts) {
      this._concurrency = opts && opts.concurrency || 1;
      this._paused = opts && !!opts.paused || false;
      this._pool = [];
      for (var i = 0; i < this._concurrency; i++) {
        this._pool.push(new WorkQueue(opts));
      }
      this._next = 0;
    }
    WorkPool.prototype.length = function() {
      var len6 = 0;
      for (var i = 0; i < this._pool.length; i++) {
        len6 += this._pool[i].length();
      }
      return len6;
    };
    WorkPool.prototype.push = function(fn, cb) {
      var i = this._next;
      var cancel = this._pool[i].push(fn, cb);
      this._next = mod(this._next + 1, this._concurrency);
      return cancel;
    };
    WorkPool.prototype.pause = function() {
      if (!this._paused) {
        this._paused = true;
        for (var i = 0; i < this._concurrency; i++) {
          this._pool[i].pause();
        }
      }
    };
    WorkPool.prototype.resume = function() {
      if (this._paused) {
        this._paused = false;
        for (var i = 0; i < this._concurrency; i++) {
          this._pool[i].resume();
        }
      }
    };
    module.exports = WorkPool;
  }
});

// node_modules/marzipano/src/util/noop.js
var require_noop = __commonJS({
  "node_modules/marzipano/src/util/noop.js"(exports, module) {
    "use strict";
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/marzipano/src/util/chain.js
var require_chain = __commonJS({
  "node_modules/marzipano/src/util/chain.js"(exports, module) {
    "use strict";
    var noop = require_noop();
    function chain() {
      var argList = Array.prototype.slice.call(arguments, 0);
      return function chained() {
        var fnList = argList.slice(0);
        var fn = null;
        var cfn = null;
        var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];
        var done = arguments.length ? arguments[arguments.length - 1] : noop;
        function exec() {
          var err = arguments[0];
          if (err) {
            fn = cfn = null;
            done.apply(null, arguments);
            return;
          }
          if (!fnList.length) {
            fn = cfn = null;
            done.apply(null, arguments);
            return;
          }
          fn = fnList.shift();
          var _fn = fn;
          var ret = Array.prototype.slice.call(arguments, 1);
          ret.push(exec);
          var _cfn = fn.apply(null, ret);
          if (_fn !== fn) {
            return;
          }
          if (typeof _cfn !== "function") {
            throw new Error("chain: chaining on non-cancellable function");
          } else {
            cfn = _cfn;
          }
        }
        function cancel() {
          if (cfn) {
            cfn.apply(null, arguments);
          }
        }
        args.unshift(null);
        exec.apply(null, args);
        return cancel;
      };
    }
    module.exports = chain;
  }
});

// node_modules/marzipano/src/util/delay.js
var require_delay = __commonJS({
  "node_modules/marzipano/src/util/delay.js"(exports, module) {
    "use strict";
    function delay(ms, done) {
      var timer = null;
      function finish() {
        if (timer != null) {
          timer = null;
          done(null);
        }
      }
      function cancel() {
        if (timer != null) {
          clearTimeout(timer);
          timer = null;
          done.apply(null, arguments);
        }
      }
      timer = setTimeout(finish, ms);
      return cancel;
    }
    module.exports = delay;
  }
});

// node_modules/marzipano/src/sources/ImageUrl.js
var require_ImageUrl = __commonJS({
  "node_modules/marzipano/src/sources/ImageUrl.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var NetworkError = require_NetworkError();
    var WorkPool = require_WorkPool();
    var chain = require_chain();
    var delay = require_delay();
    var now = require_now();
    var templateProperties = {
      x: "x",
      y: "y",
      z: "z",
      f: "face"
    };
    var defaultCubeMapFaceOrder = "bdflru";
    var defaultConcurrency = 4;
    var defaultRetryDelay = 1e4;
    function ImageUrlSource(sourceFromTile, opts) {
      opts = opts ? opts : {};
      this._loadPool = new WorkPool({
        concurrency: opts.concurrency || defaultConcurrency
      });
      this._retryDelay = opts.retryDelay || defaultRetryDelay;
      this._retryMap = {};
      this._sourceFromTile = sourceFromTile;
    }
    eventEmitter(ImageUrlSource);
    ImageUrlSource.prototype.loadAsset = function(stage, tile2, done) {
      var self2 = this;
      var retryDelay = this._retryDelay;
      var retryMap = this._retryMap;
      var tileSource = this._sourceFromTile(tile2);
      var url = tileSource.url;
      var rect = tileSource.rect;
      var loadImage = stage.loadImage.bind(stage, url, rect);
      var loadFn = function(done2) {
        return self2._loadPool.push(loadImage, function(err, asset) {
          if (err) {
            if (err instanceof NetworkError) {
              retryMap[url] = now();
              self2.emit("networkError", err, tile2);
            }
            done2(err, tile2);
          } else {
            delete retryMap[url];
            done2(null, tile2, asset);
          }
        });
      };
      var delayAmount;
      var lastTime = retryMap[url];
      if (lastTime != null) {
        var currentTime = now();
        var elapsed = currentTime - lastTime;
        if (elapsed < retryDelay) {
          delayAmount = retryDelay - elapsed;
        } else {
          delayAmount = 0;
          delete retryMap[url];
        }
      }
      var delayFn = delay.bind(null, delayAmount);
      return chain(delayFn, loadFn)(done);
    };
    ImageUrlSource.fromString = function(url, opts) {
      opts = opts || {};
      var faceOrder = opts && opts.cubeMapPreviewFaceOrder || defaultCubeMapFaceOrder;
      var urlFn = opts.cubeMapPreviewUrl ? withPreview : withoutPreview;
      return new ImageUrlSource(urlFn, opts);
      function withoutPreview(tile2) {
        var tileUrl = url;
        for (var property in templateProperties) {
          var templateProperty = templateProperties[property];
          var regExp = propertyRegExp(property);
          var valueFromTile = tile2.hasOwnProperty(templateProperty) ? tile2[templateProperty] : "";
          tileUrl = tileUrl.replace(regExp, valueFromTile);
        }
        return { url: tileUrl };
      }
      function withPreview(tile2) {
        if (tile2.z === 0) {
          return cubeMapUrl(tile2);
        } else {
          return withoutPreview(tile2);
        }
      }
      function cubeMapUrl(tile2) {
        var y = faceOrder.indexOf(tile2.face) / 6;
        return {
          url: opts.cubeMapPreviewUrl,
          rect: { x: 0, y, width: 1, height: 1 / 6 }
        };
      }
    };
    function propertyRegExp(property) {
      var regExpStr = "\\{(" + property + ")\\}";
      return new RegExp(regExpStr, "g");
    }
    module.exports = ImageUrlSource;
  }
});

// node_modules/marzipano/src/sources/SingleAsset.js
var require_SingleAsset = __commonJS({
  "node_modules/marzipano/src/sources/SingleAsset.js"(exports, module) {
    "use strict";
    function SingleAssetSource(asset) {
      this._asset = asset;
    }
    SingleAssetSource.prototype.asset = function() {
      return this._asset;
    };
    SingleAssetSource.prototype.loadAsset = function(stage, tile2, done) {
      var self2 = this;
      var timeout = setTimeout(function() {
        done(null, tile2, self2._asset);
      }, 0);
      function cancel() {
        clearTimeout(timeout);
        done.apply(null, arguments);
      }
      return cancel;
    };
    module.exports = SingleAssetSource;
  }
});

// node_modules/marzipano/src/assets/Dynamic.js
var require_Dynamic = __commonJS({
  "node_modules/marzipano/src/assets/Dynamic.js"(exports, module) {
    "use strict";
    var StaticAsset = require_Static();
    var inherits = require_inherits();
    var eventEmitter = require_minimal_event_emitter();
    var clearOwnProperties = require_clearOwnProperties();
    function DynamicAsset(element) {
      this.constructor.super_.call(this, element);
      this._timestamp = 0;
    }
    inherits(DynamicAsset, StaticAsset);
    eventEmitter(DynamicAsset);
    DynamicAsset.prototype.destroy = function() {
      clearOwnProperties(this);
    };
    DynamicAsset.prototype.timestamp = function() {
      return this._timestamp;
    };
    DynamicAsset.prototype.isDynamic = function() {
      return true;
    };
    DynamicAsset.prototype.markDirty = function() {
      this._timestamp++;
      this.emit("change");
    };
    module.exports = DynamicAsset;
  }
});

// node_modules/marzipano/src/collections/Map.js
var require_Map = __commonJS({
  "node_modules/marzipano/src/collections/Map.js"(exports, module) {
    "use strict";
    var mod = require_mod();
    var defaultCapacity = 64;
    function Map(capacity) {
      if (capacity != null && (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
        throw new Error("Map: invalid capacity");
      }
      this._capacity = capacity || defaultCapacity;
      this._keyBuckets = [];
      this._valBuckets = [];
      for (var i = 0; i < this._capacity; i++) {
        this._keyBuckets.push([]);
        this._valBuckets.push([]);
      }
      this._size = 0;
    }
    Map.prototype.get = function(key) {
      var h = mod(key.hash(), this._capacity);
      var keyBucket = this._keyBuckets[h];
      for (var i = 0; i < keyBucket.length; i++) {
        var existingKey = keyBucket[i];
        if (key.equals(existingKey)) {
          var valBucket = this._valBuckets[h];
          var existingValue = valBucket[i];
          return existingValue;
        }
      }
      return null;
    };
    Map.prototype.set = function(key, val) {
      var h = mod(key.hash(), this._capacity);
      var keyBucket = this._keyBuckets[h];
      var valBucket = this._valBuckets[h];
      for (var i = 0; i < keyBucket.length; i++) {
        var existingKey = keyBucket[i];
        if (key.equals(existingKey)) {
          var existingValue = valBucket[i];
          keyBucket[i] = key;
          valBucket[i] = val;
          return existingValue;
        }
      }
      keyBucket.push(key);
      valBucket.push(val);
      this._size++;
      return null;
    };
    Map.prototype.del = function(key) {
      var h = mod(key.hash(), this._capacity);
      var keyBucket = this._keyBuckets[h];
      var valBucket = this._valBuckets[h];
      for (var i = 0; i < keyBucket.length; i++) {
        var existingKey = keyBucket[i];
        if (key.equals(existingKey)) {
          var existingValue = valBucket[i];
          for (var j = i; j < keyBucket.length - 1; j++) {
            keyBucket[j] = keyBucket[j + 1];
            valBucket[j] = valBucket[j + 1];
          }
          keyBucket.length = keyBucket.length - 1;
          valBucket.length = valBucket.length - 1;
          this._size--;
          return existingValue;
        }
      }
      return null;
    };
    Map.prototype.has = function(key) {
      var h = mod(key.hash(), this._capacity);
      var keyBucket = this._keyBuckets[h];
      for (var i = 0; i < keyBucket.length; i++) {
        var existingKey = keyBucket[i];
        if (key.equals(existingKey)) {
          return true;
        }
      }
      return false;
    };
    Map.prototype.size = function() {
      return this._size;
    };
    Map.prototype.clear = function() {
      for (var i = 0; i < this._capacity; i++) {
        this._keyBuckets[i].length = 0;
        this._valBuckets[i].length = 0;
      }
      this._size = 0;
    };
    Map.prototype.forEach = function(fn) {
      var count = 0;
      for (var i = 0; i < this._capacity; i++) {
        var keyBucket = this._keyBuckets[i];
        var valBucket = this._valBuckets[i];
        for (var j = 0; j < keyBucket.length; j++) {
          fn(keyBucket[j], valBucket[j]);
          count += 1;
        }
      }
      return count;
    };
    module.exports = Map;
  }
});

// node_modules/marzipano/src/collections/LruSet.js
var require_LruSet = __commonJS({
  "node_modules/marzipano/src/collections/LruSet.js"(exports, module) {
    "use strict";
    var mod = require_mod();
    function LruSet(capacity) {
      if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
        throw new Error("LruSet: invalid capacity");
      }
      this._capacity = capacity;
      this._elements = new Array(this._capacity);
      this._start = 0;
      this._size = 0;
    }
    LruSet.prototype._index = function(i) {
      return mod(this._start + i, this._capacity);
    };
    LruSet.prototype.add = function(element) {
      if (this._capacity === 0) {
        return element;
      }
      this.remove(element);
      var evictedElement = this._size === this._capacity ? this._elements[this._index(0)] : null;
      this._elements[this._index(this._size)] = element;
      if (this._size < this._capacity) {
        this._size++;
      } else {
        this._start = this._index(1);
      }
      return evictedElement;
    };
    LruSet.prototype.remove = function(element) {
      for (var i = 0; i < this._size; i++) {
        var existingElement = this._elements[this._index(i)];
        if (element.equals(existingElement)) {
          for (var j = i; j < this._size - 1; j++) {
            this._elements[this._index(j)] = this._elements[this._index(j + 1)];
          }
          this._size--;
          return existingElement;
        }
      }
      return null;
    };
    LruSet.prototype.has = function(element) {
      for (var i = 0; i < this._size; i++) {
        if (element.equals(this._elements[this._index(i)])) {
          return true;
        }
      }
      return false;
    };
    LruSet.prototype.size = function() {
      return this._size;
    };
    LruSet.prototype.clear = function() {
      this._elements.length = 0;
      this._start = 0;
      this._size = 0;
    };
    LruSet.prototype.forEach = function(fn) {
      var count = 0;
      for (var i = 0; i < this._size; i++) {
        fn(this._elements[this._index(i)]);
        count += 1;
      }
      return count;
    };
    module.exports = LruSet;
  }
});

// node_modules/marzipano/src/util/defaults.js
var require_defaults = __commonJS({
  "node_modules/marzipano/src/util/defaults.js"(exports, module) {
    "use strict";
    function defaults(obj, defaultsObj) {
      for (var key in defaultsObj) {
        if (!(key in obj)) {
          obj[key] = defaultsObj[key];
        }
      }
      return obj;
    }
    module.exports = defaults;
  }
});

// node_modules/marzipano/src/util/retry.js
var require_retry = __commonJS({
  "node_modules/marzipano/src/util/retry.js"(exports, module) {
    "use strict";
    var noop = require_noop();
    function retry(fn) {
      return function retried() {
        var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];
        var done = arguments.length ? arguments[arguments.length - 1] : noop;
        var cfn = null;
        var canceled = false;
        function exec() {
          var err = arguments[0];
          if (!err || canceled) {
            done.apply(null, arguments);
          } else {
            cfn = fn.apply(null, args);
          }
        }
        args.push(exec);
        exec(true);
        return function cancel() {
          canceled = true;
          cfn.apply(null, arguments);
        };
      };
    }
    module.exports = retry;
  }
});

// node_modules/marzipano/src/TextureStore.js
var require_TextureStore = __commonJS({
  "node_modules/marzipano/src/TextureStore.js"(exports, module) {
    "use strict";
    var Map = require_Map();
    var Set = require_Set();
    var LruSet = require_LruSet();
    var eventEmitter = require_minimal_event_emitter();
    var defaults = require_defaults();
    var retry = require_retry();
    var chain = require_chain();
    var inherits = require_inherits();
    var clearOwnProperties = require_clearOwnProperties();
    var debug = typeof MARZIPANODEBUG !== "undefined" && MARZIPANODEBUG.textureStore;
    var State = {
      IDLE: 0,
      START: 1,
      MARK: 2,
      END: 3
    };
    var defaultOptions = {
      // Maximum number of cached textures for previously visible tiles.
      previouslyVisibleCacheSize: 512
    };
    var nextId = 0;
    function CancelError() {
    }
    inherits(CancelError, Error);
    function TextureStoreItem(store, tile2) {
      var self2 = this;
      var id = nextId++;
      self2._id = id;
      self2._store = store;
      self2._tile = tile2;
      self2._asset = null;
      self2._texture = null;
      self2._changeHandler = function() {
        store.emit("textureInvalid", tile2);
      };
      var source = store.source();
      var stage = store.stage();
      var loadAsset = source.loadAsset.bind(source);
      var createTexture = stage.createTexture.bind(stage);
      var fn = chain(retry(loadAsset), createTexture);
      store.emit("textureStartLoad", tile2);
      if (debug) {
        console.log("loading", id, tile2);
      }
      self2._cancel = fn(stage, tile2, function(err, _tile, asset, texture) {
        self2._cancel = null;
        if (err) {
          if (asset) {
            asset.destroy();
          }
          if (texture) {
            texture.destroy();
          }
          if (err instanceof CancelError) {
            store.emit("textureCancel", tile2);
            if (debug) {
              console.log("cancel", id, tile2);
            }
          } else {
            store.emit("textureError", tile2, err);
            if (debug) {
              console.log("error", id, tile2);
            }
          }
          return;
        }
        self2._texture = texture;
        if (asset.isDynamic()) {
          self2._asset = asset;
          asset.addEventListener("change", self2._changeHandler);
        } else {
          asset.destroy();
        }
        store.emit("textureLoad", tile2);
        if (debug) {
          console.log("load", id, tile2);
        }
      });
    }
    TextureStoreItem.prototype.asset = function() {
      return this._asset;
    };
    TextureStoreItem.prototype.texture = function() {
      return this._texture;
    };
    TextureStoreItem.prototype.destroy = function() {
      var id = this._id;
      var store = this._store;
      var tile2 = this._tile;
      var asset = this._asset;
      var texture = this._texture;
      var cancel = this._cancel;
      if (cancel) {
        cancel(new CancelError("Texture load cancelled"));
        return;
      }
      if (asset) {
        asset.removeEventListener("change", this._changeHandler);
        asset.destroy();
      }
      if (texture) {
        texture.destroy();
      }
      store.emit("textureUnload", tile2);
      if (debug) {
        console.log("unload", id, tile2);
      }
      clearOwnProperties(this);
    };
    eventEmitter(TextureStoreItem);
    function TextureStore(source, stage, opts) {
      opts = defaults(opts || {}, defaultOptions);
      this._source = source;
      this._stage = stage;
      this._state = State.IDLE;
      this._delimCount = 0;
      this._itemMap = new Map();
      this._visible = new Set();
      this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);
      this._pinMap = new Map();
      this._newVisible = new Set();
      this._noLongerVisible = [];
      this._visibleAgain = [];
      this._evicted = [];
    }
    eventEmitter(TextureStore);
    TextureStore.prototype.destroy = function() {
      this.clear();
      clearOwnProperties(this);
    };
    TextureStore.prototype.stage = function() {
      return this._stage;
    };
    TextureStore.prototype.source = function() {
      return this._source;
    };
    TextureStore.prototype.clear = function() {
      var self2 = this;
      self2._evicted.length = 0;
      self2._itemMap.forEach(function(tile2) {
        self2._evicted.push(tile2);
      });
      self2._evicted.forEach(function(tile2) {
        self2._unloadTile(tile2);
      });
      self2._itemMap.clear();
      self2._visible.clear();
      self2._previouslyVisible.clear();
      self2._pinMap.clear();
      self2._newVisible.clear();
      self2._noLongerVisible.length = 0;
      self2._visibleAgain.length = 0;
      self2._evicted.length = 0;
    };
    TextureStore.prototype.clearNotPinned = function() {
      var self2 = this;
      self2._evicted.length = 0;
      self2._itemMap.forEach(function(tile2) {
        if (!self2._pinMap.has(tile2)) {
          self2._evicted.push(tile2);
        }
      });
      self2._evicted.forEach(function(tile2) {
        self2._unloadTile(tile2);
      });
      self2._visible.clear();
      self2._previouslyVisible.clear();
      self2._evicted.length = 0;
    };
    TextureStore.prototype.startFrame = function() {
      if (this._state !== State.IDLE && this._state !== State.START) {
        throw new Error("TextureStore: startFrame called out of sequence");
      }
      this._state = State.START;
      this._delimCount++;
    };
    TextureStore.prototype.markTile = function(tile2) {
      if (this._state !== State.START && this._state !== State.MARK) {
        throw new Error("TextureStore: markTile called out of sequence");
      }
      this._state = State.MARK;
      var item = this._itemMap.get(tile2);
      var texture = item && item.texture();
      var asset = item && item.asset();
      if (texture && asset) {
        texture.refresh(tile2, asset);
      }
      this._newVisible.add(tile2);
    };
    TextureStore.prototype.endFrame = function() {
      if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {
        throw new Error("TextureStore: endFrame called out of sequence");
      }
      this._state = State.END;
      this._delimCount--;
      if (!this._delimCount) {
        this._update();
        this._state = State.IDLE;
      }
    };
    TextureStore.prototype._update = function() {
      var self2 = this;
      self2._noLongerVisible.length = 0;
      self2._visible.forEach(function(tile2) {
        if (!self2._newVisible.has(tile2)) {
          self2._noLongerVisible.push(tile2);
        }
      });
      self2._visibleAgain.length = 0;
      self2._newVisible.forEach(function(tile2) {
        if (self2._previouslyVisible.has(tile2)) {
          self2._visibleAgain.push(tile2);
        }
      });
      self2._visibleAgain.forEach(function(tile2) {
        self2._previouslyVisible.remove(tile2);
      });
      self2._evicted.length = 0;
      self2._noLongerVisible.forEach(function(tile2) {
        var item = self2._itemMap.get(tile2);
        var texture = item && item.texture();
        if (texture) {
          var otherTile = self2._previouslyVisible.add(tile2);
          if (otherTile != null) {
            self2._evicted.push(otherTile);
          }
        } else if (item) {
          self2._unloadTile(tile2);
        }
      });
      self2._evicted.forEach(function(tile2) {
        if (!self2._pinMap.has(tile2)) {
          self2._unloadTile(tile2);
        }
      });
      self2._newVisible.forEach(function(tile2) {
        var item = self2._itemMap.get(tile2);
        if (!item) {
          self2._loadTile(tile2);
        }
      });
      var tmp = self2._visible;
      self2._visible = self2._newVisible;
      self2._newVisible = tmp;
      self2._newVisible.clear();
      self2._noLongerVisible.length = 0;
      self2._visibleAgain.length = 0;
      self2._evicted.length = 0;
    };
    TextureStore.prototype._loadTile = function(tile2) {
      if (this._itemMap.has(tile2)) {
        throw new Error("TextureStore: loading texture already in cache");
      }
      var item = new TextureStoreItem(this, tile2);
      this._itemMap.set(tile2, item);
    };
    TextureStore.prototype._unloadTile = function(tile2) {
      var item = this._itemMap.del(tile2);
      if (!item) {
        throw new Error("TextureStore: unloading texture not in cache");
      }
      item.destroy();
    };
    TextureStore.prototype.asset = function(tile2) {
      var item = this._itemMap.get(tile2);
      if (item) {
        return item.asset();
      }
      return null;
    };
    TextureStore.prototype.texture = function(tile2) {
      var item = this._itemMap.get(tile2);
      if (item) {
        return item.texture();
      }
      return null;
    };
    TextureStore.prototype.pin = function(tile2) {
      var count = (this._pinMap.get(tile2) || 0) + 1;
      this._pinMap.set(tile2, count);
      if (!this._itemMap.has(tile2)) {
        this._loadTile(tile2);
      }
      return count;
    };
    TextureStore.prototype.unpin = function(tile2) {
      var count = this._pinMap.get(tile2);
      if (!count) {
        throw new Error("TextureStore: unpin when not pinned");
      } else {
        count--;
        if (count > 0) {
          this._pinMap.set(tile2, count);
        } else {
          this._pinMap.del(tile2);
          if (!this._visible.has(tile2) && !this._previouslyVisible.has(tile2)) {
            this._unloadTile(tile2);
          }
        }
      }
      return count;
    };
    TextureStore.prototype.query = function(tile2) {
      var item = this._itemMap.get(tile2);
      var pinCount = this._pinMap.get(tile2) || 0;
      return {
        visible: this._visible.has(tile2),
        previouslyVisible: this._previouslyVisible.has(tile2),
        hasAsset: item != null && item.asset() != null,
        hasTexture: item != null && item.texture() != null,
        pinned: pinCount !== 0,
        pinCount
      };
    };
    module.exports = TextureStore;
  }
});

// node_modules/marzipano/src/util/extend.js
var require_extend = __commonJS({
  "node_modules/marzipano/src/util/extend.js"(exports, module) {
    "use strict";
    function extend(obj, sourceObj) {
      for (var key in sourceObj) {
        obj[key] = sourceObj[key];
      }
      return obj;
    }
    module.exports = extend;
  }
});

// node_modules/marzipano/src/Layer.js
var require_Layer = __commonJS({
  "node_modules/marzipano/src/Layer.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var extend = require_extend();
    var clearOwnProperties = require_clearOwnProperties();
    function Layer(source, geometry, view, textureStore, opts) {
      opts = opts || {};
      var self2 = this;
      this._source = source;
      this._geometry = geometry;
      this._view = view;
      this._textureStore = textureStore;
      this._effects = opts.effects || {};
      this._fixedLevelIndex = null;
      this._viewChangeHandler = function() {
        self2.emit("viewChange", self2.view());
      };
      this._view.addEventListener("change", this._viewChangeHandler);
      this._textureStoreChangeHandler = function() {
        self2.emit("textureStoreChange", self2.textureStore());
      };
      this._textureStore.addEventListener(
        "textureLoad",
        this._textureStoreChangeHandler
      );
      this._textureStore.addEventListener(
        "textureError",
        this._textureStoreChangeHandler
      );
      this._textureStore.addEventListener(
        "textureInvalid",
        this._textureStoreChangeHandler
      );
    }
    eventEmitter(Layer);
    Layer.prototype.destroy = function() {
      this._view.removeEventListener("change", this._viewChangeHandler);
      this._textureStore.removeEventListener(
        "textureLoad",
        this._textureStoreChangeHandler
      );
      this._textureStore.removeEventListener(
        "textureError",
        this._textureStoreChangeHandler
      );
      this._textureStore.removeEventListener(
        "textureInvalid",
        this._textureStoreChangeHandler
      );
      clearOwnProperties(this);
    };
    Layer.prototype.source = function() {
      return this._source;
    };
    Layer.prototype.geometry = function() {
      return this._geometry;
    };
    Layer.prototype.view = function() {
      return this._view;
    };
    Layer.prototype.textureStore = function() {
      return this._textureStore;
    };
    Layer.prototype.effects = function() {
      return this._effects;
    };
    Layer.prototype.setEffects = function(effects) {
      this._effects = effects;
      this.emit("effectsChange", this._effects);
    };
    Layer.prototype.mergeEffects = function(effects) {
      extend(this._effects, effects);
      this.emit("effectsChange", this._effects);
    };
    Layer.prototype.fixedLevel = function() {
      return this._fixedLevelIndex;
    };
    Layer.prototype.setFixedLevel = function(levelIndex) {
      if (levelIndex !== this._fixedLevelIndex) {
        if (levelIndex != null && (levelIndex >= this._geometry.levelList.length || levelIndex < 0)) {
          throw new Error("Level index out of range: " + levelIndex);
        }
        this._fixedLevelIndex = levelIndex;
        this.emit("fixedLevelChange", this._fixedLevelIndex);
      }
    };
    Layer.prototype._selectLevel = function() {
      var level;
      if (this._fixedLevelIndex != null) {
        level = this._geometry.levelList[this._fixedLevelIndex];
      } else {
        level = this._view.selectLevel(this._geometry.selectableLevelList);
      }
      return level;
    };
    Layer.prototype.visibleTiles = function(result) {
      var level = this._selectLevel();
      return this._geometry.visibleTiles(this._view, level, result);
    };
    Layer.prototype.pinLevel = function(levelIndex) {
      var level = this._geometry.levelList[levelIndex];
      var tiles = this._geometry.levelTiles(level);
      for (var i = 0; i < tiles.length; i++) {
        this._textureStore.pin(tiles[i]);
      }
    };
    Layer.prototype.unpinLevel = function(levelIndex) {
      var level = this._geometry.levelList[levelIndex];
      var tiles = this._geometry.levelTiles(level);
      for (var i = 0; i < tiles.length; i++) {
        this._textureStore.unpin(tiles[i]);
      }
    };
    Layer.prototype.pinFirstLevel = function() {
      return this.pinLevel(0);
    };
    Layer.prototype.unpinFirstLevel = function() {
      return this.unpinLevel(0);
    };
    module.exports = Layer;
  }
});

// node_modules/marzipano/src/RenderLoop.js
var require_RenderLoop = __commonJS({
  "node_modules/marzipano/src/RenderLoop.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var clearOwnProperties = require_clearOwnProperties();
    function RenderLoop(stage) {
      var self2 = this;
      this._stage = stage;
      this._running = false;
      this._rendering = false;
      this._requestHandle = null;
      this._boundLoop = this._loop.bind(this);
      this._renderInvalidHandler = function() {
        if (!self2._rendering) {
          self2.renderOnNextFrame();
        }
      };
      this._stage.addEventListener("renderInvalid", this._renderInvalidHandler);
    }
    eventEmitter(RenderLoop);
    RenderLoop.prototype.destroy = function() {
      this.stop();
      this._stage.removeEventListener("renderInvalid", this._renderInvalidHandler);
      clearOwnProperties(this);
    };
    RenderLoop.prototype.stage = function() {
      return this._stage;
    };
    RenderLoop.prototype.start = function() {
      this._running = true;
      this.renderOnNextFrame();
    };
    RenderLoop.prototype.stop = function() {
      if (this._requestHandle) {
        window.cancelAnimationFrame(this._requestHandle);
        this._requestHandle = null;
      }
      this._running = false;
    };
    RenderLoop.prototype.renderOnNextFrame = function() {
      if (this._running && !this._requestHandle) {
        this._requestHandle = window.requestAnimationFrame(this._boundLoop);
      }
    };
    RenderLoop.prototype._loop = function() {
      if (!this._running) {
        throw new Error("Render loop running while in stopped state");
      }
      this._requestHandle = null;
      this._rendering = true;
      this.emit("beforeRender");
      this._rendering = false;
      this._stage.render();
      this.emit("afterRender");
    };
    module.exports = RenderLoop;
  }
});

// node_modules/marzipano/src/controls/Dynamics.js
var require_Dynamics = __commonJS({
  "node_modules/marzipano/src/controls/Dynamics.js"(exports, module) {
    "use strict";
    function Dynamics() {
      this.velocity = null;
      this.friction = null;
      this.offset = null;
    }
    Dynamics.equals = function(d1, d2) {
      return d1.velocity === d2.velocity && d1.friction === d2.friction && d1.offset === d2.offset;
    };
    Dynamics.prototype.equals = function(other) {
      return Dynamics.equals(this, other);
    };
    Dynamics.prototype.update = function(other, elapsed) {
      if (other.offset) {
        this.offset = this.offset || 0;
        this.offset += other.offset;
      }
      var offsetFromVelocity = this.offsetFromVelocity(elapsed);
      if (offsetFromVelocity) {
        this.offset = this.offset || 0;
        this.offset += offsetFromVelocity;
      }
      this.velocity = other.velocity;
      this.friction = other.friction;
    };
    Dynamics.prototype.reset = function() {
      this.velocity = null;
      this.friction = null;
      this.offset = null;
    };
    Dynamics.prototype.velocityAfter = function(elapsed) {
      if (!this.velocity) {
        return null;
      }
      if (this.friction) {
        return decreaseAbs(this.velocity, this.friction * elapsed);
      }
      return this.velocity;
    };
    Dynamics.prototype.offsetFromVelocity = function(elapsed) {
      elapsed = Math.min(elapsed, this.nullVelocityTime());
      var velocityEnd = this.velocityAfter(elapsed);
      var averageVelocity = (this.velocity + velocityEnd) / 2;
      return averageVelocity * elapsed;
    };
    Dynamics.prototype.nullVelocityTime = function() {
      if (this.velocity == null) {
        return 0;
      }
      if (this.velocity && !this.friction) {
        return Infinity;
      }
      return Math.abs(this.velocity / this.friction);
    };
    function decreaseAbs(num, dec) {
      if (num < 0) {
        return Math.min(0, num + dec);
      }
      if (num > 0) {
        return Math.max(0, num - dec);
      }
      return 0;
    }
    module.exports = Dynamics;
  }
});

// node_modules/marzipano/src/controls/Key.js
var require_Key = __commonJS({
  "node_modules/marzipano/src/controls/Key.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var clearOwnProperties = require_clearOwnProperties();
    function KeyControlMethod(keyCode, parameter, velocity, friction, element) {
      if (!keyCode) {
        throw new Error("KeyControlMethod: keyCode must be defined");
      }
      if (!parameter) {
        throw new Error("KeyControlMethod: parameter must be defined");
      }
      if (!velocity) {
        throw new Error("KeyControlMethod: velocity must be defined");
      }
      if (!friction) {
        throw new Error("KeyControlMethod: friction must be defined");
      }
      element = element || document;
      this._keyCode = keyCode;
      this._parameter = parameter;
      this._velocity = velocity;
      this._friction = friction;
      this._element = element;
      this._keydownHandler = this._handlePress.bind(this);
      this._keyupHandler = this._handleRelease.bind(this);
      this._blurHandler = this._handleBlur.bind(this);
      this._element.addEventListener("keydown", this._keydownHandler);
      this._element.addEventListener("keyup", this._keyupHandler);
      window.addEventListener("blur", this._blurHandler);
      this._dynamics = new Dynamics();
      this._pressing = false;
    }
    eventEmitter(KeyControlMethod);
    KeyControlMethod.prototype.destroy = function() {
      this._element.removeEventListener("keydown", this._keydownHandler);
      this._element.removeEventListener("keyup", this._keyupHandler);
      window.removeEventListener("blur", this._blurHandler);
      clearOwnProperties(this);
    };
    KeyControlMethod.prototype._handlePress = function(e) {
      if (e.keyCode !== this._keyCode) {
        return;
      }
      this._pressing = true;
      this._dynamics.velocity = this._velocity;
      this._dynamics.friction = 0;
      this.emit("parameterDynamics", this._parameter, this._dynamics);
      this.emit("active");
    };
    KeyControlMethod.prototype._handleRelease = function(e) {
      if (e.keyCode !== this._keyCode) {
        return;
      }
      if (this._pressing) {
        this._dynamics.friction = this._friction;
        this.emit("parameterDynamics", this._parameter, this._dynamics);
        this.emit("inactive");
      }
      this._pressing = false;
    };
    KeyControlMethod.prototype._handleBlur = function() {
      this._dynamics.velocity = 0;
      this.emit("parameterDynamics", this._parameter, this._dynamics);
      this.emit("inactive");
      this._pressing = false;
    };
    module.exports = KeyControlMethod;
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round4 = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function extend(dest, src, merge2) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }
      function merge(dest, src) {
        return extend(dest, src, true);
      }
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          extend(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str10, find) {
        return str10.indexOf(find) > -1;
      }
      function splitStr(str10) {
        return str10.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle2(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = last.deltaX - input.deltaX;
          var deltaY = last.deltaY - input.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round4(input.pointers[i].clientX),
            clientY: round4(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round4(pointers[0].clientX),
            y: round4(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round4(x / pointersLength),
          y: round4(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle2(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation2(start, end) {
        return getAngle2(end[1], end[0], PROPS_CLIENT_XY) - getAngle2(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true;
        this.pressed = false;
        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }
          if (!this.pressed || !this.allow) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
      }
      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isTouch) {
            this.mouse.allow = false;
          } else if (isMouse && !this.mouse.allow) {
            return;
          }
          if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          if (NATIVE_TOUCH_ACTION) {
            return;
          }
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_PAN_X + " " + TOUCH_ACTION_PAN_Y;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          extend(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(withState) {
            self2.manager.emit(self2.options.event + (withState ? stateStr(state) : ""), input);
          }
          if (state < STATE_ENDED) {
            emit(true);
          }
          emit();
          if (state >= STATE_ENDED) {
            emit(true);
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = extend({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance4 = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance4 = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance4 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance4 > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          this._super.emit.call(this, input);
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            this.manager.emit(this.options.event + inOut, input);
          }
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 500,
          // minimal time of the pointer to be pressed
          threshold: 5
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.65,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
          var direction = directionStr(input.direction);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 2,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
      }
      Hammer.VERSION = "2.0.4";
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          extend(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          var recognizers = this.recognizers;
          recognizer = this.get(recognizer);
          recognizers.splice(inArray(recognizers, recognizer), 1);
          this.touchAction.update();
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add10) {
        var element = manager.element;
        each(manager.options.cssProps, function(value, name) {
          element.style[prefixed(element.style, name)] = add10 ? value : "";
        });
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      extend(Hammer, {
        INPUT_START,
        INPUT_MOVE,
        INPUT_END,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager,
        Input,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend,
        inherit,
        bindFn,
        prefixed
      });
      if (typeof define == TYPE_FUNCTION && define.amd) {
        define(function() {
          return Hammer;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
      } else {
        window2[exportName] = Hammer;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/marzipano/src/controls/HammerGestures.js
var require_HammerGestures = __commonJS({
  "node_modules/marzipano/src/controls/HammerGestures.js"(exports, module) {
    "use strict";
    var Hammer = require_hammer();
    var nextId = 1;
    var idProperty = "MarzipanoHammerElementId";
    function getKeyForElementAndType(element, type) {
      if (!element[idProperty]) {
        element[idProperty] = nextId++;
      }
      return type + element[idProperty];
    }
    function HammerGestures() {
      this._managers = {};
      this._refCount = {};
    }
    HammerGestures.prototype.get = function(element, type) {
      var key = getKeyForElementAndType(element, type);
      if (!this._managers[key]) {
        this._managers[key] = this._createManager(element, type);
        this._refCount[key] = 0;
      }
      this._refCount[key]++;
      return new HammerGesturesHandle(this, this._managers[key], element, type);
    };
    HammerGestures.prototype._createManager = function(element, type) {
      var manager = new Hammer.Manager(element);
      if (type === "mouse") {
        manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 0 }));
      } else if (type === "touch" || type === "pen" || type === "kinect") {
        manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 20, pointers: 1 }));
        manager.add(new Hammer.Pinch());
      }
      return manager;
    };
    HammerGestures.prototype._releaseHandle = function(element, type) {
      var key = getKeyForElementAndType(element, type);
      if (this._refCount[key]) {
        this._refCount[key]--;
        if (!this._refCount[key]) {
          this._managers[key].destroy();
          delete this._managers[key];
          delete this._refCount[key];
        }
      }
    };
    function HammerGesturesHandle(hammerGestures, manager, element, type) {
      this._manager = manager;
      this._element = element;
      this._type = type;
      this._hammerGestures = hammerGestures;
      this._eventHandlers = [];
    }
    HammerGesturesHandle.prototype.on = function(events, handler) {
      var type = this._type;
      var handlerFilteredEvents = function(e) {
        if (type === e.pointerType) {
          handler(e);
        }
      };
      this._eventHandlers.push({ events, handler: handlerFilteredEvents });
      this._manager.on(events, handlerFilteredEvents);
    };
    HammerGesturesHandle.prototype.release = function() {
      for (var i = 0; i < this._eventHandlers.length; i++) {
        var eventHandler = this._eventHandlers[i];
        this._manager.off(eventHandler.events, eventHandler.handler);
      }
      this._hammerGestures._releaseHandle(this._element, this._type);
      this._manager = null;
      this._element = null;
      this._type = null;
      this._hammerGestures = null;
    };
    HammerGesturesHandle.prototype.manager = function() {
      return this._manager;
    };
    module.exports = new HammerGestures();
  }
});

// node_modules/marzipano/src/controls/util.js
var require_util = __commonJS({
  "node_modules/marzipano/src/controls/util.js"(exports, module) {
    "use strict";
    function maxFriction(friction, velocityX, velocityY, maxFrictionTime, result) {
      var velocity = Math.sqrt(Math.pow(velocityX, 2) + Math.pow(velocityY, 2));
      friction = Math.max(friction, velocity / maxFrictionTime);
      changeVectorNorm(velocityX, velocityY, friction, result);
      result[0] = Math.abs(result[0]);
      result[1] = Math.abs(result[1]);
    }
    function changeVectorNorm(x, y, n, result) {
      var theta = Math.atan(y / x);
      result[0] = n * Math.cos(theta);
      result[1] = n * Math.sin(theta);
    }
    module.exports = {
      maxFriction,
      changeVectorNorm
    };
  }
});

// node_modules/marzipano/src/controls/Drag.js
var require_Drag = __commonJS({
  "node_modules/marzipano/src/controls/Drag.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var HammerGestures = require_HammerGestures();
    var defaults = require_defaults();
    var maxFriction = require_util().maxFriction;
    var clearOwnProperties = require_clearOwnProperties();
    var defaultOptions = {
      friction: 6,
      maxFrictionTime: 0.3,
      hammerEvent: "pan"
    };
    var debug = typeof MARZIPANODEBUG !== "undefined" && MARZIPANODEBUG.controls;
    function DragControlMethod(element, pointerType, opts) {
      this._element = element;
      this._opts = defaults(opts || {}, defaultOptions);
      this._startEvent = null;
      this._lastEvent = null;
      this._active = false;
      this._dynamics = {
        x: new Dynamics(),
        y: new Dynamics()
      };
      this._hammer = HammerGestures.get(element, pointerType);
      this._hammer.on("hammer.input", this._handleHammerEvent.bind(this));
      if (this._opts.hammerEvent != "pan" && this._opts.hammerEvent != "pinch") {
        throw new Error(this._opts.hammerEvent + " is not a hammerEvent managed in DragControlMethod");
      }
      this._hammer.on(this._opts.hammerEvent + "start", this._handleStart.bind(this));
      this._hammer.on(this._opts.hammerEvent + "move", this._handleMove.bind(this));
      this._hammer.on(this._opts.hammerEvent + "end", this._handleEnd.bind(this));
      this._hammer.on(this._opts.hammerEvent + "cancel", this._handleEnd.bind(this));
    }
    eventEmitter(DragControlMethod);
    DragControlMethod.prototype.destroy = function() {
      this._hammer.release();
      clearOwnProperties(this);
    };
    DragControlMethod.prototype._handleHammerEvent = function(e) {
      if (e.isFirst) {
        if (debug && this._active) {
          throw new Error("DragControlMethod active detected when already active");
        }
        this._active = true;
        this.emit("active");
      }
      if (e.isFinal) {
        if (debug && !this._active) {
          throw new Error("DragControlMethod inactive detected when already inactive");
        }
        this._active = false;
        this.emit("inactive");
      }
    };
    DragControlMethod.prototype._handleStart = function(e) {
      e.preventDefault();
      this._startEvent = e;
    };
    DragControlMethod.prototype._handleMove = function(e) {
      e.preventDefault();
      if (this._startEvent) {
        this._updateDynamicsMove(e);
        this.emit("parameterDynamics", "axisScaledX", this._dynamics.x);
        this.emit("parameterDynamics", "axisScaledY", this._dynamics.y);
      }
    };
    DragControlMethod.prototype._handleEnd = function(e) {
      e.preventDefault();
      if (this._startEvent) {
        this._updateDynamicsRelease(e);
        this.emit("parameterDynamics", "axisScaledX", this._dynamics.x);
        this.emit("parameterDynamics", "axisScaledY", this._dynamics.y);
      }
      this._startEvent = false;
      this._lastEvent = false;
    };
    DragControlMethod.prototype._updateDynamicsMove = function(e) {
      var x = e.deltaX;
      var y = e.deltaY;
      var eventToSubtract = this._lastEvent || this._startEvent;
      if (eventToSubtract) {
        x -= eventToSubtract.deltaX;
        y -= eventToSubtract.deltaY;
      }
      var elementRect = this._element.getBoundingClientRect();
      var width = elementRect.right - elementRect.left;
      var height = elementRect.bottom - elementRect.top;
      x /= width;
      y /= height;
      this._dynamics.x.reset();
      this._dynamics.y.reset();
      this._dynamics.x.offset = -x;
      this._dynamics.y.offset = -y;
      this._lastEvent = e;
    };
    var tmpReleaseFriction = [null, null];
    DragControlMethod.prototype._updateDynamicsRelease = function(e) {
      var elementRect = this._element.getBoundingClientRect();
      var width = elementRect.right - elementRect.left;
      var height = elementRect.bottom - elementRect.top;
      var x = 1e3 * e.velocityX / width;
      var y = 1e3 * e.velocityY / height;
      this._dynamics.x.reset();
      this._dynamics.y.reset();
      this._dynamics.x.velocity = x;
      this._dynamics.y.velocity = y;
      maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
      this._dynamics.x.friction = tmpReleaseFriction[0];
      this._dynamics.y.friction = tmpReleaseFriction[1];
    };
    module.exports = DragControlMethod;
  }
});

// node_modules/marzipano/src/controls/Qtvr.js
var require_Qtvr = __commonJS({
  "node_modules/marzipano/src/controls/Qtvr.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var HammerGestures = require_HammerGestures();
    var defaults = require_defaults();
    var maxFriction = require_util().maxFriction;
    var clearOwnProperties = require_clearOwnProperties();
    var defaultOptions = {
      speed: 8,
      friction: 6,
      maxFrictionTime: 0.3
    };
    function QtvrControlMethod(element, pointerType, opts) {
      this._element = element;
      this._opts = defaults(opts || {}, defaultOptions);
      this._active = false;
      this._hammer = HammerGestures.get(element, pointerType);
      this._dynamics = {
        x: new Dynamics(),
        y: new Dynamics()
      };
      this._hammer.on("panstart", this._handleStart.bind(this));
      this._hammer.on("panmove", this._handleMove.bind(this));
      this._hammer.on("panend", this._handleRelease.bind(this));
      this._hammer.on("pancancel", this._handleRelease.bind(this));
    }
    eventEmitter(QtvrControlMethod);
    QtvrControlMethod.prototype.destroy = function() {
      this._hammer.release();
      clearOwnProperties(this);
    };
    QtvrControlMethod.prototype._handleStart = function(e) {
      e.preventDefault();
      if (!this._active) {
        this._active = true;
        this.emit("active");
      }
    };
    QtvrControlMethod.prototype._handleMove = function(e) {
      e.preventDefault();
      this._updateDynamics(e, false);
    };
    QtvrControlMethod.prototype._handleRelease = function(e) {
      e.preventDefault();
      this._updateDynamics(e, true);
      if (this._active) {
        this._active = false;
        this.emit("inactive");
      }
    };
    var tmpReleaseFriction = [null, null];
    QtvrControlMethod.prototype._updateDynamics = function(e, release) {
      var elementRect = this._element.getBoundingClientRect();
      var width = elementRect.right - elementRect.left;
      var height = elementRect.bottom - elementRect.top;
      var maxDim = Math.max(width, height);
      var x = e.deltaX / maxDim * this._opts.speed;
      var y = e.deltaY / maxDim * this._opts.speed;
      this._dynamics.x.reset();
      this._dynamics.y.reset();
      this._dynamics.x.velocity = x;
      this._dynamics.y.velocity = y;
      if (release) {
        maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
        this._dynamics.x.friction = tmpReleaseFriction[0];
        this._dynamics.y.friction = tmpReleaseFriction[1];
      }
      this.emit("parameterDynamics", "x", this._dynamics.x);
      this.emit("parameterDynamics", "y", this._dynamics.y);
    };
    module.exports = QtvrControlMethod;
  }
});

// node_modules/marzipano/src/controls/ScrollZoom.js
var require_ScrollZoom = __commonJS({
  "node_modules/marzipano/src/controls/ScrollZoom.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var defaults = require_defaults();
    var clearOwnProperties = require_clearOwnProperties();
    var defaultOptions = {
      frictionTime: 0.2,
      zoomDelta: 1e-3
    };
    function ScrollZoomControlMethod(element, opts) {
      this._element = element;
      this._opts = defaults(opts || {}, defaultOptions);
      this._dynamics = new Dynamics();
      this._eventList = [];
      var fn = this._opts.frictionTime ? this.withSmoothing : this.withoutSmoothing;
      this._wheelListener = fn.bind(this);
      element.addEventListener("wheel", this._wheelListener);
    }
    eventEmitter(ScrollZoomControlMethod);
    ScrollZoomControlMethod.prototype.destroy = function() {
      this._element.removeEventListener("wheel", this._wheelListener);
      clearOwnProperties(this);
    };
    ScrollZoomControlMethod.prototype.withoutSmoothing = function(e) {
      this._dynamics.offset = wheelEventDelta(e) * this._opts.zoomDelta;
      this.emit("parameterDynamics", "zoom", this._dynamics);
      e.preventDefault();
      this.emit("active");
      this.emit("inactive");
    };
    ScrollZoomControlMethod.prototype.withSmoothing = function(e) {
      var currentTime = e.timeStamp;
      this._eventList.push(e);
      while (this._eventList[0].timeStamp < currentTime - this._opts.frictionTime * 1e3) {
        this._eventList.shift(0);
      }
      var velocity = 0;
      for (var i = 0; i < this._eventList.length; i++) {
        var zoomChangeFromEvent = wheelEventDelta(this._eventList[i]) * this._opts.zoomDelta;
        velocity += zoomChangeFromEvent / this._opts.frictionTime;
      }
      this._dynamics.velocity = velocity;
      this._dynamics.friction = Math.abs(velocity) / this._opts.frictionTime;
      this.emit("parameterDynamics", "zoom", this._dynamics);
      e.preventDefault();
      this.emit("active");
      this.emit("inactive");
    };
    function wheelEventDelta(e) {
      var multiplier = e.deltaMode == 1 ? 20 : 1;
      return e.deltaY * multiplier;
    }
    module.exports = ScrollZoomControlMethod;
  }
});

// node_modules/marzipano/src/controls/PinchZoom.js
var require_PinchZoom = __commonJS({
  "node_modules/marzipano/src/controls/PinchZoom.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var HammerGestures = require_HammerGestures();
    var clearOwnProperties = require_clearOwnProperties();
    function PinchZoomControlMethod(element, pointerType, opts) {
      this._hammer = HammerGestures.get(element, pointerType);
      this._lastEvent = null;
      this._active = false;
      this._dynamics = new Dynamics();
      this._hammer.on("pinchstart", this._handleStart.bind(this));
      this._hammer.on("pinch", this._handleEvent.bind(this));
      this._hammer.on("pinchend", this._handleEnd.bind(this));
      this._hammer.on("pinchcancel", this._handleEnd.bind(this));
    }
    eventEmitter(PinchZoomControlMethod);
    PinchZoomControlMethod.prototype.destroy = function() {
      this._hammer.release();
      clearOwnProperties(this);
    };
    PinchZoomControlMethod.prototype._handleStart = function() {
      if (!this._active) {
        this._active = true;
        this.emit("active");
      }
    };
    PinchZoomControlMethod.prototype._handleEnd = function() {
      this._lastEvent = null;
      if (this._active) {
        this._active = false;
        this.emit("inactive");
      }
    };
    PinchZoomControlMethod.prototype._handleEvent = function(e) {
      var scale10 = e.scale;
      if (this._lastEvent) {
        scale10 /= this._lastEvent.scale;
      }
      this._dynamics.offset = (scale10 - 1) * -1;
      this.emit("parameterDynamics", "zoom", this._dynamics);
      this._lastEvent = e;
    };
    module.exports = PinchZoomControlMethod;
  }
});

// node_modules/marzipano/src/controls/Velocity.js
var require_Velocity = __commonJS({
  "node_modules/marzipano/src/controls/Velocity.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var clearOwnProperties = require_clearOwnProperties();
    function VelocityControlMethod(parameter) {
      if (!parameter) {
        throw new Error("VelocityControlMethod: parameter must be defined");
      }
      this._parameter = parameter;
      this._dynamics = new Dynamics();
    }
    eventEmitter(VelocityControlMethod);
    VelocityControlMethod.prototype.destroy = function() {
      clearOwnProperties(this);
    };
    VelocityControlMethod.prototype.setVelocity = function(velocity) {
      this._dynamics.velocity = velocity;
      this.emit("parameterDynamics", this._parameter, this._dynamics);
    };
    VelocityControlMethod.prototype.setFriction = function(friction) {
      this._dynamics.friction = friction;
      this.emit("parameterDynamics", this._parameter, this._dynamics);
    };
    module.exports = VelocityControlMethod;
  }
});

// node_modules/marzipano/src/controls/ElementPress.js
var require_ElementPress = __commonJS({
  "node_modules/marzipano/src/controls/ElementPress.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var clearOwnProperties = require_clearOwnProperties();
    function ElementPressControlMethod(element, parameter, velocity, friction) {
      if (!element) {
        throw new Error("ElementPressControlMethod: element must be defined");
      }
      if (!parameter) {
        throw new Error("ElementPressControlMethod: parameter must be defined");
      }
      if (!velocity) {
        throw new Error("ElementPressControlMethod: velocity must be defined");
      }
      if (!friction) {
        throw new Error("ElementPressControlMethod: friction must be defined");
      }
      this._element = element;
      this._pressHandler = this._handlePress.bind(this);
      this._releaseHandler = this._handleRelease.bind(this);
      element.addEventListener("mousedown", this._pressHandler);
      element.addEventListener("mouseup", this._releaseHandler);
      element.addEventListener("mouseleave", this._releaseHandler);
      element.addEventListener("touchstart", this._pressHandler);
      element.addEventListener("touchmove", this._releaseHandler);
      element.addEventListener("touchend", this._releaseHandler);
      this._parameter = parameter;
      this._velocity = velocity;
      this._friction = friction;
      this._dynamics = new Dynamics();
      this._pressing = false;
    }
    eventEmitter(ElementPressControlMethod);
    ElementPressControlMethod.prototype.destroy = function() {
      this._element.removeEventListener("mousedown", this._pressHandler);
      this._element.removeEventListener("mouseup", this._releaseHandler);
      this._element.removeEventListener("mouseleave", this._releaseHandler);
      this._element.removeEventListener("touchstart", this._pressHandler);
      this._element.removeEventListener("touchmove", this._releaseHandler);
      this._element.removeEventListener("touchend", this._releaseHandler);
      clearOwnProperties(this);
    };
    ElementPressControlMethod.prototype._handlePress = function() {
      this._pressing = true;
      this._dynamics.velocity = this._velocity;
      this._dynamics.friction = 0;
      this.emit("parameterDynamics", this._parameter, this._dynamics);
      this.emit("active");
    };
    ElementPressControlMethod.prototype._handleRelease = function() {
      if (this._pressing) {
        this._dynamics.friction = this._friction;
        this.emit("parameterDynamics", this._parameter, this._dynamics);
        this.emit("inactive");
      }
      this._pressing = false;
    };
    module.exports = ElementPressControlMethod;
  }
});

// node_modules/marzipano/src/controls/Composer.js
var require_Composer = __commonJS({
  "node_modules/marzipano/src/controls/Composer.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Dynamics = require_Dynamics();
    var now = require_now();
    var clearOwnProperties = require_clearOwnProperties();
    function ControlComposer(opts) {
      opts = opts || {};
      this._methods = [];
      this._parameters = ["x", "y", "axisScaledX", "axisScaledY", "zoom", "yaw", "pitch", "roll"];
      this._now = opts.nowForTesting || now;
      this._composedOffsets = {};
      this._composeReturn = { offsets: this._composedOffsets, changing: null };
    }
    eventEmitter(ControlComposer);
    ControlComposer.prototype.add = function(instance) {
      if (this.has(instance)) {
        return;
      }
      var dynamics = {};
      this._parameters.forEach(function(parameter) {
        dynamics[parameter] = {
          dynamics: new Dynamics(),
          time: null
        };
      });
      var parameterDynamicsHandler = this._updateDynamics.bind(this, dynamics);
      var method = {
        instance,
        dynamics,
        parameterDynamicsHandler
      };
      instance.addEventListener("parameterDynamics", parameterDynamicsHandler);
      this._methods.push(method);
    };
    ControlComposer.prototype.remove = function(instance) {
      var index = this._indexOfInstance(instance);
      if (index >= 0) {
        var method = this._methods.splice(index, 1)[0];
        method.instance.removeEventListener("parameterDynamics", method.parameterDynamicsHandler);
      }
    };
    ControlComposer.prototype.has = function(instance) {
      return this._indexOfInstance(instance) >= 0;
    };
    ControlComposer.prototype._indexOfInstance = function(instance) {
      for (var i = 0; i < this._methods.length; i++) {
        if (this._methods[i].instance === instance) {
          return i;
        }
      }
      return -1;
    };
    ControlComposer.prototype.list = function() {
      var instances = [];
      for (var i = 0; i < this._methods.length; i++) {
        instances.push(this._methods[i].instance);
      }
      return instances;
    };
    ControlComposer.prototype._updateDynamics = function(storedDynamics, parameter, dynamics) {
      var parameterDynamics = storedDynamics[parameter];
      if (!parameterDynamics) {
        throw new Error("Unknown control parameter " + parameter);
      }
      var newTime = this._now();
      parameterDynamics.dynamics.update(dynamics, (newTime - parameterDynamics.time) / 1e3);
      parameterDynamics.time = newTime;
      this.emit("change");
    };
    ControlComposer.prototype._resetComposedOffsets = function() {
      for (var i = 0; i < this._parameters.length; i++) {
        this._composedOffsets[this._parameters[i]] = 0;
      }
    };
    ControlComposer.prototype.offsets = function() {
      var parameter;
      var changing = false;
      var currentTime = this._now();
      this._resetComposedOffsets();
      for (var i = 0; i < this._methods.length; i++) {
        var methodDynamics = this._methods[i].dynamics;
        for (var p = 0; p < this._parameters.length; p++) {
          parameter = this._parameters[p];
          var parameterDynamics = methodDynamics[parameter];
          var dynamics = parameterDynamics.dynamics;
          if (dynamics.offset != null) {
            this._composedOffsets[parameter] += dynamics.offset;
            dynamics.offset = null;
          }
          var elapsed = (currentTime - parameterDynamics.time) / 1e3;
          var offsetFromVelocity = dynamics.offsetFromVelocity(elapsed);
          if (offsetFromVelocity) {
            this._composedOffsets[parameter] += offsetFromVelocity;
          }
          var currentVelocity = dynamics.velocityAfter(elapsed);
          dynamics.velocity = currentVelocity;
          if (currentVelocity) {
            changing = true;
          }
          parameterDynamics.time = currentTime;
        }
      }
      this._composeReturn.changing = changing;
      return this._composeReturn;
    };
    ControlComposer.prototype.destroy = function() {
      var instances = this.list();
      for (var i = 0; i < instances.length; i++) {
        this.remove(instances[i]);
      }
      clearOwnProperties(this);
    };
    module.exports = ControlComposer;
  }
});

// node_modules/marzipano/src/controls/Controls.js
var require_Controls = __commonJS({
  "node_modules/marzipano/src/controls/Controls.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Composer = require_Composer();
    var clearOwnProperties = require_clearOwnProperties();
    var debug = typeof MARZIPANODEBUG !== "undefined" && MARZIPANODEBUG.controls;
    function Controls(opts) {
      opts = opts || {};
      this._methods = {};
      this._methodGroups = {};
      this._composer = new Composer();
      this._enabled = opts && opts.enabled ? !!opts.enabled : true;
      this._activeCount = 0;
      this.updatedViews_ = [];
      this._attachedRenderLoop = null;
    }
    eventEmitter(Controls);
    Controls.prototype.destroy = function() {
      this.detach();
      this._composer.destroy();
      clearOwnProperties(this);
    };
    Controls.prototype.methods = function() {
      var obj = {};
      for (var id in this._methods) {
        obj[id] = this._methods[id];
      }
      return obj;
    };
    Controls.prototype.method = function(id) {
      return this._methods[id];
    };
    Controls.prototype.registerMethod = function(id, instance, enable) {
      if (this._methods[id]) {
        throw new Error("Control method already registered with id " + id);
      }
      this._methods[id] = {
        instance,
        enabled: false,
        active: false,
        activeHandler: this._handleActive.bind(this, id),
        inactiveHandler: this._handleInactive.bind(this, id)
      };
      if (enable) {
        this.enableMethod(id, instance);
      }
    };
    Controls.prototype.unregisterMethod = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("No control method registered with id " + id);
      }
      if (method.enabled) {
        this.disableMethod(id);
      }
      delete this._methods[id];
    };
    Controls.prototype.enableMethod = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("No control method registered with id " + id);
      }
      if (method.enabled) {
        return;
      }
      method.enabled = true;
      if (method.active) {
        this._incrementActiveCount();
      }
      this._listen(id);
      this._updateComposer();
      this.emit("methodEnabled", id);
    };
    Controls.prototype.disableMethod = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("No control method registered with id " + id);
      }
      if (!method.enabled) {
        return;
      }
      method.enabled = false;
      if (method.active) {
        this._decrementActiveCount();
      }
      this._unlisten(id);
      this._updateComposer();
      this.emit("methodDisabled", id);
    };
    Controls.prototype.addMethodGroup = function(groupId, methodIds) {
      this._methodGroups[groupId] = methodIds;
    };
    Controls.prototype.removeMethodGroup = function(id) {
      delete this._methodGroups[id];
    };
    Controls.prototype.methodGroups = function() {
      var obj = {};
      for (var id in this._methodGroups) {
        obj[id] = this._methodGroups[id];
      }
      return obj;
    };
    Controls.prototype.enableMethodGroup = function(id) {
      var self2 = this;
      self2._methodGroups[id].forEach(function(methodId) {
        self2.enableMethod(methodId);
      });
    };
    Controls.prototype.disableMethodGroup = function(id) {
      var self2 = this;
      self2._methodGroups[id].forEach(function(methodId) {
        self2.disableMethod(methodId);
      });
    };
    Controls.prototype.enabled = function() {
      return this._enabled;
    };
    Controls.prototype.enable = function() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._activeCount > 0) {
        this.emit("active");
      }
      this.emit("enabled");
      this._updateComposer();
    };
    Controls.prototype.disable = function() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      if (this._activeCount > 0) {
        this.emit("inactive");
      }
      this.emit("disabled");
      this._updateComposer();
    };
    Controls.prototype.attach = function(renderLoop) {
      if (this._attachedRenderLoop) {
        this.detach();
      }
      this._attachedRenderLoop = renderLoop;
      this._beforeRenderHandler = this._updateViewsWithControls.bind(this);
      this._changeHandler = renderLoop.renderOnNextFrame.bind(renderLoop);
      this._attachedRenderLoop.addEventListener("beforeRender", this._beforeRenderHandler);
      this._composer.addEventListener("change", this._changeHandler);
    };
    Controls.prototype.detach = function() {
      if (!this._attachedRenderLoop) {
        return;
      }
      this._attachedRenderLoop.removeEventListener("beforeRender", this._beforeRenderHandler);
      this._composer.removeEventListener("change", this._changeHandler);
      this._beforeRenderHandler = null;
      this._changeHandler = null;
      this._attachedRenderLoop = null;
    };
    Controls.prototype.attached = function() {
      return this._attachedRenderLoop != null;
    };
    Controls.prototype._listen = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("Bad method id");
      }
      method.instance.addEventListener("active", method.activeHandler);
      method.instance.addEventListener("inactive", method.inactiveHandler);
    };
    Controls.prototype._unlisten = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("Bad method id");
      }
      method.instance.removeEventListener("active", method.activeHandler);
      method.instance.removeEventListener("inactive", method.inactiveHandler);
    };
    Controls.prototype._handleActive = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("Bad method id");
      }
      if (!method.enabled) {
        throw new Error("Should not receive event from disabled control method");
      }
      if (!method.active) {
        method.active = true;
        this._incrementActiveCount();
      }
    };
    Controls.prototype._handleInactive = function(id) {
      var method = this._methods[id];
      if (!method) {
        throw new Error("Bad method id");
      }
      if (!method.enabled) {
        throw new Error("Should not receive event from disabled control method");
      }
      if (method.active) {
        method.active = false;
        this._decrementActiveCount();
      }
    };
    Controls.prototype._incrementActiveCount = function() {
      this._activeCount++;
      if (debug) {
        this._checkActiveCount();
      }
      if (this._enabled && this._activeCount === 1) {
        this.emit("active");
      }
    };
    Controls.prototype._decrementActiveCount = function() {
      this._activeCount--;
      if (debug) {
        this._checkActiveCount();
      }
      if (this._enabled && this._activeCount === 0) {
        this.emit("inactive");
      }
    };
    Controls.prototype._checkActiveCount = function() {
      var count = 0;
      for (var id in this._methods) {
        var method = this._methods[id];
        if (method.enabled && method.active) {
          count++;
        }
      }
      if (count != this._activeCount) {
        throw new Error("Bad control state");
      }
    };
    Controls.prototype._updateComposer = function() {
      var composer = this._composer;
      for (var id in this._methods) {
        var method = this._methods[id];
        var enabled = this._enabled && method.enabled;
        if (enabled && !composer.has(method.instance)) {
          composer.add(method.instance);
        }
        if (!enabled && composer.has(method.instance)) {
          composer.remove(method.instance);
        }
      }
    };
    Controls.prototype._updateViewsWithControls = function() {
      var controlData = this._composer.offsets();
      if (controlData.changing) {
        this._attachedRenderLoop.renderOnNextFrame();
      }
      this.updatedViews_.length = 0;
      var layers = this._attachedRenderLoop.stage().listLayers();
      for (var i = 0; i < layers.length; i++) {
        var view = layers[i].view();
        if (this.updatedViews_.indexOf(view) < 0) {
          layers[i].view().updateWithControlParameters(controlData.offsets);
          this.updatedViews_.push(view);
        }
      }
    };
    module.exports = Controls;
  }
});

// node_modules/marzipano/src/util/positionAbsolutely.js
var require_positionAbsolutely = __commonJS({
  "node_modules/marzipano/src/util/positionAbsolutely.js"(exports, module) {
    "use strict";
    var setTransform = require_dom().setTransform;
    var decimal = require_decimal();
    function positionAbsolutely(element, x, y, extraTransforms) {
      extraTransforms = extraTransforms || "";
      var transform = "translateX(" + decimal(x) + "px) translateY(" + decimal(y) + "px) translateZ(0) " + extraTransforms;
      setTransform(element, transform);
    }
    module.exports = positionAbsolutely;
  }
});

// node_modules/marzipano/src/Hotspot.js
var require_Hotspot = __commonJS({
  "node_modules/marzipano/src/Hotspot.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var positionAbsolutely = require_positionAbsolutely();
    var setTransform = require_dom().setTransform;
    var clearOwnProperties = require_clearOwnProperties();
    function Hotspot(domElement, parentDomElement, view, coords, opts) {
      opts = opts || {};
      opts.perspective = opts.perspective || {};
      opts.perspective.extraTransforms = opts.perspective.extraTransforms != null ? opts.perspective.extraTransforms : "";
      this._domElement = domElement;
      this._parentDomElement = parentDomElement;
      this._view = view;
      this._coords = {};
      this._perspective = {};
      this.setPosition(coords);
      this._parentDomElement.appendChild(this._domElement);
      this.setPerspective(opts.perspective);
      this._visible = true;
      this._position = { x: 0, y: 0 };
    }
    eventEmitter(Hotspot);
    Hotspot.prototype.destroy = function() {
      this._parentDomElement.removeChild(this._domElement);
      clearOwnProperties(this);
    };
    Hotspot.prototype.domElement = function() {
      return this._domElement;
    };
    Hotspot.prototype.position = function() {
      return this._coords;
    };
    Hotspot.prototype.setPosition = function(coords) {
      for (var key in coords) {
        this._coords[key] = coords[key];
      }
      this._update();
    };
    Hotspot.prototype.perspective = function() {
      return this._perspective;
    };
    Hotspot.prototype.setPerspective = function(perspective2) {
      for (var key in perspective2) {
        this._perspective[key] = perspective2[key];
      }
      this._update();
    };
    Hotspot.prototype.show = function() {
      if (!this._visible) {
        this._visible = true;
        this._update();
      }
    };
    Hotspot.prototype.hide = function() {
      if (this._visible) {
        this._visible = false;
        this._update();
      }
    };
    Hotspot.prototype._update = function() {
      var element = this._domElement;
      var params = this._coords;
      var position = this._position;
      var x, y;
      var isVisible = false;
      if (this._visible) {
        var view = this._view;
        if (this._perspective.radius) {
          isVisible = true;
          this._setEmbeddedPosition(view, params);
        } else {
          view.coordinatesToScreen(params, position);
          x = position.x;
          y = position.y;
          if (x != null && y != null) {
            isVisible = true;
            this._setPosition(x, y);
          }
        }
      }
      if (isVisible) {
        element.style.display = "block";
        element.style.position = "absolute";
      } else {
        element.style.display = "none";
        element.style.position = "";
      }
    };
    Hotspot.prototype._setEmbeddedPosition = function(view, params) {
      var transform = view.coordinatesToPerspectiveTransform(
        params,
        this._perspective.radius,
        this._perspective.extraTransforms
      );
      setTransform(this._domElement, transform);
    };
    Hotspot.prototype._setPosition = function(x, y) {
      positionAbsolutely(this._domElement, x, y, this._perspective.extraTransforms);
    };
    module.exports = Hotspot;
  }
});

// node_modules/marzipano/src/HotspotContainer.js
var require_HotspotContainer = __commonJS({
  "node_modules/marzipano/src/HotspotContainer.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var Hotspot = require_Hotspot();
    var calcRect = require_calcRect();
    var positionAbsolutely = require_positionAbsolutely();
    var setAbsolute = require_dom().setAbsolute;
    var setOverflowHidden = require_dom().setOverflowHidden;
    var setOverflowVisible = require_dom().setOverflowVisible;
    var setNullSize = require_dom().setNullSize;
    var setPixelSize = require_dom().setPixelSize;
    var setPointerEvents = require_dom().setWithVendorPrefix("pointer-events");
    var clearOwnProperties = require_clearOwnProperties();
    function HotspotContainer(parentDomElement, stage, view, renderLoop, opts) {
      opts = opts || {};
      this._parentDomElement = parentDomElement;
      this._stage = stage;
      this._view = view;
      this._renderLoop = renderLoop;
      this._hotspots = [];
      this._visible = true;
      this._rect = opts.rect;
      this._visibilityOrRectChanged = true;
      this._stageWidth = null;
      this._stageHeight = null;
      this._tmpRect = {};
      this._hotspotContainerWrapper = document.createElement("div");
      setAbsolute(this._hotspotContainerWrapper);
      setPointerEvents(this._hotspotContainerWrapper, "none");
      this._parentDomElement.appendChild(this._hotspotContainerWrapper);
      this._hotspotContainer = document.createElement("div");
      setAbsolute(this._hotspotContainer);
      setPointerEvents(this._hotspotContainer, "all");
      this._hotspotContainerWrapper.appendChild(this._hotspotContainer);
      this._updateHandler = this._update.bind(this);
      this._renderLoop.addEventListener("afterRender", this._updateHandler);
    }
    eventEmitter(HotspotContainer);
    HotspotContainer.prototype.destroy = function() {
      while (this._hotspots.length) {
        this.destroyHotspot(this._hotspots[0]);
      }
      this._parentDomElement.removeChild(this._hotspotContainerWrapper);
      this._renderLoop.removeEventListener("afterRender", this._updateHandler);
      clearOwnProperties(this);
    };
    HotspotContainer.prototype.domElement = function() {
      return this._hotspotContainer;
    };
    HotspotContainer.prototype.setRect = function(rect) {
      this._rect = rect;
      this._visibilityOrRectChanged = true;
    };
    HotspotContainer.prototype.rect = function() {
      return this._rect;
    };
    HotspotContainer.prototype.createHotspot = function(domElement, coords, opts) {
      coords = coords || {};
      var hotspot = new Hotspot(
        domElement,
        this._hotspotContainer,
        this._view,
        coords,
        opts
      );
      this._hotspots.push(hotspot);
      hotspot._update();
      this.emit("hotspotsChange");
      return hotspot;
    };
    HotspotContainer.prototype.hasHotspot = function(hotspot) {
      return this._hotspots.indexOf(hotspot) >= 0;
    };
    HotspotContainer.prototype.listHotspots = function() {
      return [].concat(this._hotspots);
    };
    HotspotContainer.prototype.destroyHotspot = function(hotspot) {
      var i = this._hotspots.indexOf(hotspot);
      if (i < 0) {
        throw new Error("No such hotspot");
      }
      this._hotspots.splice(i, 1);
      hotspot.destroy();
      this.emit("hotspotsChange");
    };
    HotspotContainer.prototype.hide = function() {
      if (this._visible) {
        this._visible = false;
        this._visibilityOrRectChanged = true;
        this._update();
      }
    };
    HotspotContainer.prototype.show = function() {
      if (!this._visible) {
        this._visible = true;
        this._visibilityOrRectChanged = true;
        this._update();
      }
    };
    HotspotContainer.prototype._update = function() {
      var wrapper = this._hotspotContainerWrapper;
      var width = this._stage.width();
      var height = this._stage.height();
      var tmpRect = this._tmpRect;
      if (this._visibilityOrRectChanged || this._rect && (width !== this._stageWidth || height !== this._stageHeight)) {
        var visible = this._visible;
        wrapper.style.display = visible ? "block" : "none";
        if (visible) {
          if (this._rect) {
            calcRect(width, height, this._rect, tmpRect);
            positionAbsolutely(wrapper, width * tmpRect.x, height * tmpRect.y);
            setPixelSize(wrapper, width * tmpRect.width, height * tmpRect.height);
            setOverflowHidden(wrapper);
          } else {
            positionAbsolutely(wrapper, 0, 0);
            setNullSize(wrapper);
            setOverflowVisible(wrapper);
          }
        }
        this._stageWidth = width;
        this._stageHeight = height;
        this._visibilityOrRectChanged = false;
      }
      for (var i = 0; i < this._hotspots.length; i++) {
        this._hotspots[i]._update();
      }
    };
    module.exports = HotspotContainer;
  }
});

// node_modules/marzipano/src/Scene.js
var require_Scene = __commonJS({
  "node_modules/marzipano/src/Scene.js"(exports, module) {
    "use strict";
    var Layer = require_Layer();
    var TextureStore = require_TextureStore();
    var HotspotContainer = require_HotspotContainer();
    var eventEmitter = require_minimal_event_emitter();
    var now = require_now();
    var noop = require_noop();
    var type = require_type();
    var defaults = require_defaults();
    var clearOwnProperties = require_clearOwnProperties();
    function Scene(viewer, view) {
      this._viewer = viewer;
      this._view = view;
      this._layers = [];
      this._hotspotContainer = new HotspotContainer(
        viewer._controlContainer,
        viewer.stage(),
        this._view,
        viewer.renderLoop()
      );
      this._movement = null;
      this._movementStartTime = null;
      this._movementStep = null;
      this._movementParams = null;
      this._movementCallback = null;
      this._updateMovementHandler = this._updateMovement.bind(this);
      this._updateHotspotContainerHandler = this._updateHotspotContainer.bind(this);
      this._viewer.addEventListener("sceneChange", this._updateHotspotContainerHandler);
      this._viewChangeHandler = this.emit.bind(this, "viewChange");
      this._view.addEventListener("change", this._viewChangeHandler);
      this._updateHotspotContainer();
    }
    eventEmitter(Scene);
    Scene.prototype.destroy = function() {
      this._view.removeEventListener("change", this._viewChangeHandler);
      this._viewer.removeEventListener("sceneChange", this._updateHotspotContainerHandler);
      if (this._movement) {
        this.stopMovement();
      }
      this._hotspotContainer.destroy();
      this.destroyAllLayers();
      clearOwnProperties(this);
    };
    Scene.prototype.hotspotContainer = function() {
      return this._hotspotContainer;
    };
    Scene.prototype.layer = function() {
      return this._layers[0];
    };
    Scene.prototype.listLayers = function() {
      return [].concat(this._layers);
    };
    Scene.prototype.view = function() {
      return this._view;
    };
    Scene.prototype.viewer = function() {
      return this._viewer;
    };
    Scene.prototype.visible = function() {
      return this._viewer.scene() === this;
    };
    Scene.prototype.createLayer = function(opts) {
      opts = opts || {};
      var textureStoreOpts = opts.textureStoreOpts || {};
      var layerOpts = opts.layerOpts || {};
      var source = opts.source;
      var geometry = opts.geometry;
      var view = this._view;
      var stage = this._viewer.stage();
      var textureStore = new TextureStore(source, stage, textureStoreOpts);
      var layer = new Layer(source, geometry, view, textureStore, layerOpts);
      this._layers.push(layer);
      if (opts.pinFirstLevel) {
        layer.pinFirstLevel();
      }
      this.emit("layerChange");
      return layer;
    };
    Scene.prototype.destroyLayer = function(layer) {
      var i = this._layers.indexOf(layer);
      if (i < 0) {
        throw new Error("No such layer in scene");
      }
      this._layers.splice(i, 1);
      this.emit("layerChange");
      layer.textureStore().destroy();
      layer.destroy();
    };
    Scene.prototype.destroyAllLayers = function() {
      while (this._layers.length > 0) {
        this.destroyLayer(this._layers[0]);
      }
    };
    Scene.prototype.switchTo = function(opts, done) {
      return this._viewer.switchScene(this, opts, done);
    };
    Scene.prototype.lookTo = function(params, opts, done) {
      var self2 = this;
      opts = opts || {};
      done = done || noop;
      if (type(params) !== "object") {
        throw new Error("Target view parameters must be an object");
      }
      var easeInOutQuad = function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      };
      var ease = opts.ease != null ? opts.ease : easeInOutQuad;
      var controlsInterrupt = opts.controlsInterrupt != null ? opts.controlsInterrupt : false;
      var duration = opts.transitionDuration != null ? opts.transitionDuration : 1e3;
      var shortest = opts.shortest != null ? opts.shortest : true;
      var view = this._view;
      var initialParams = view.parameters();
      var finalParams = {};
      defaults(finalParams, params);
      defaults(finalParams, initialParams);
      if (shortest && view.normalizeToClosest) {
        view.normalizeToClosest(finalParams, finalParams);
      }
      var movement = function() {
        var finalUpdate = false;
        return function(params2, elapsed) {
          if (elapsed >= duration && finalUpdate) {
            return null;
          }
          var delta = Math.min(elapsed / duration, 1);
          for (var param in params2) {
            var start = initialParams[param];
            var end = finalParams[param];
            params2[param] = start + ease(delta) * (end - start);
          }
          finalUpdate = elapsed >= duration;
          return params2;
        };
      };
      var reenableControls = this._viewer.controls().enabled();
      if (!controlsInterrupt) {
        this._viewer.controls().disable();
      }
      this.startMovement(movement, function() {
        if (reenableControls) {
          self2._viewer.controls().enable();
        }
        done();
      });
    };
    Scene.prototype.startMovement = function(fn, done) {
      var renderLoop = this._viewer.renderLoop();
      if (this._movement) {
        this.stopMovement();
      }
      var step = fn();
      if (typeof step !== "function") {
        throw new Error("Bad movement");
      }
      this._movement = fn;
      this._movementStep = step;
      this._movementStartTime = now();
      this._movementParams = {};
      this._movementCallback = done;
      renderLoop.addEventListener("beforeRender", this._updateMovementHandler);
      renderLoop.renderOnNextFrame();
    };
    Scene.prototype.stopMovement = function() {
      var done = this._movementCallback;
      var renderLoop = this._viewer.renderLoop();
      if (!this._movement) {
        return;
      }
      this._movement = null;
      this._movementStep = null;
      this._movementStartTime = null;
      this._movementParams = null;
      this._movementCallback = null;
      renderLoop.removeEventListener("beforeRender", this._updateMovementHandler);
      if (done) {
        done();
      }
    };
    Scene.prototype.movement = function() {
      return this._movement;
    };
    Scene.prototype._updateMovement = function() {
      if (!this._movement) {
        throw new Error("Should not call update");
      }
      var renderLoop = this._viewer.renderLoop();
      var view = this._view;
      var elapsed = now() - this._movementStartTime;
      var step = this._movementStep;
      var params = this._movementParams;
      params = view.parameters(params);
      params = step(params, elapsed);
      if (params == null) {
        this.stopMovement();
      } else {
        view.setParameters(params);
        renderLoop.renderOnNextFrame();
      }
    };
    Scene.prototype._updateHotspotContainer = function() {
      if (this.visible()) {
        this._hotspotContainer.show();
      } else {
        this._hotspotContainer.hide();
      }
    };
    module.exports = Scene;
  }
});

// node_modules/marzipano/src/Timer.js
var require_Timer = __commonJS({
  "node_modules/marzipano/src/Timer.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var defaults = require_defaults();
    var now = require_now();
    var defaultOptions = {
      duration: Infinity
    };
    function Timer(opts) {
      opts = defaults(opts || {}, defaultOptions);
      this._duration = opts.duration;
      this._startTime = null;
      this._handle = null;
      this._check = this._check.bind(this);
    }
    eventEmitter(Timer);
    Timer.prototype.start = function() {
      this._startTime = now();
      if (this._handle == null && this._duration < Infinity) {
        this._setup(this._duration);
      }
    };
    Timer.prototype.started = function() {
      return this._startTime != null;
    };
    Timer.prototype.stop = function() {
      this._startTime = null;
      if (this._handle != null) {
        clearTimeout(this._handle);
        this._handle = null;
      }
    };
    Timer.prototype._setup = function(interval) {
      this._handle = setTimeout(this._check, interval);
    };
    Timer.prototype._teardown = function() {
      clearTimeout(this._handle);
      this._handle = null;
    };
    Timer.prototype._check = function() {
      var currentTime = now();
      var elapsed = currentTime - this._startTime;
      var remaining = this._duration - elapsed;
      this._teardown();
      if (remaining <= 0) {
        this.emit("timeout");
        this._startTime = null;
      } else if (remaining < Infinity) {
        this._setup(remaining);
      }
    };
    Timer.prototype.duration = function() {
      return this._duration;
    };
    Timer.prototype.setDuration = function(duration) {
      this._duration = duration;
      if (this._startTime != null) {
        this._check();
      }
    };
    module.exports = Timer;
  }
});

// node_modules/marzipano/src/controls/ControlCursor.js
var require_ControlCursor = __commonJS({
  "node_modules/marzipano/src/controls/ControlCursor.js"(exports, module) {
    "use strict";
    var defaults = require_defaults();
    var clearOwnProperties = require_clearOwnProperties();
    var defaultOpts = {
      active: "move",
      inactive: "default",
      disabled: "default"
    };
    function ControlCursor(controls, id, element, opts) {
      opts = defaults(opts || {}, defaultOpts);
      this._element = element;
      this._controls = controls;
      this._id = id;
      this._attached = false;
      this._setActiveCursor = this._setCursor.bind(this, opts.active);
      this._setInactiveCursor = this._setCursor.bind(this, opts.inactive);
      this._setDisabledCursor = this._setCursor.bind(this, opts.disabled);
      this._setOriginalCursor = this._setCursor.bind(this, this._element.style.cursor);
      this._updateAttachmentHandler = this._updateAttachment.bind(this);
      controls.addEventListener("methodEnabled", this._updateAttachmentHandler);
      controls.addEventListener("methodDisabled", this._updateAttachmentHandler);
      controls.addEventListener("enabled", this._updateAttachmentHandler);
      controls.addEventListener("disabled", this._updateAttachmentHandler);
      this._updateAttachment();
    }
    ControlCursor.prototype.destroy = function() {
      this._detachFromControlMethod(this._controls.method(this._id));
      this._setOriginalCursor();
      this._controls.removeEventListener(
        "methodEnabled",
        this._updateAttachmentHandler
      );
      this._controls.removeEventListener(
        "methodDisabled",
        this._updateAttachmentHandler
      );
      this._controls.removeEventListener(
        "enabled",
        this._updateAttachmentHandler
      );
      this._controls.removeEventListener(
        "disabled",
        this._updateAttachmentHandler
      );
      clearOwnProperties(this);
    };
    ControlCursor.prototype._updateAttachment = function() {
      var controls = this._controls;
      var id = this._id;
      if (controls.enabled() && controls.method(id).enabled) {
        this._attachToControlMethod(controls.method(id));
      } else {
        this._detachFromControlMethod(controls.method(id));
      }
    };
    ControlCursor.prototype._attachToControlMethod = function(controlMethod) {
      if (!this._attached) {
        controlMethod.instance.addEventListener("active", this._setActiveCursor);
        controlMethod.instance.addEventListener("inactive", this._setInactiveCursor);
        if (controlMethod.active) {
          this._setActiveCursor();
        } else {
          this._setInactiveCursor();
        }
        this._attached = true;
      }
    };
    ControlCursor.prototype._detachFromControlMethod = function(controlMethod) {
      if (this._attached) {
        controlMethod.instance.removeEventListener("active", this._setActiveCursor);
        controlMethod.instance.removeEventListener("inactive", this._setInactiveCursor);
        this._setDisabledCursor();
        this._attached = false;
      }
    };
    ControlCursor.prototype._setCursor = function(cursor) {
      this._element.style.cursor = cursor;
    };
    module.exports = ControlCursor;
  }
});

// node_modules/marzipano/src/controls/registerDefaultControls.js
var require_registerDefaultControls = __commonJS({
  "node_modules/marzipano/src/controls/registerDefaultControls.js"(exports, module) {
    "use strict";
    var defaults = require_defaults();
    var DragControlMethod = require_Drag();
    var QtvrControlMethod = require_Qtvr();
    var ScrollZoomControlMethod = require_ScrollZoom();
    var PinchZoomControlMethod = require_PinchZoom();
    var KeyControlMethod = require_Key();
    var defaultOptions = {
      mouseViewMode: "drag",
      dragMode: "pan"
    };
    function registerDefaultControls(controls, element, opts) {
      opts = defaults(opts || {}, defaultOptions);
      var controlMethods = {
        mouseViewDrag: new DragControlMethod(element, "mouse"),
        mouseViewQtvr: new QtvrControlMethod(element, "mouse"),
        leftArrowKey: new KeyControlMethod(37, "x", -0.7, 3),
        rightArrowKey: new KeyControlMethod(39, "x", 0.7, 3),
        upArrowKey: new KeyControlMethod(38, "y", -0.7, 3),
        downArrowKey: new KeyControlMethod(40, "y", 0.7, 3),
        plusKey: new KeyControlMethod(107, "zoom", -0.7, 3),
        minusKey: new KeyControlMethod(109, "zoom", 0.7, 3),
        wKey: new KeyControlMethod(87, "y", -0.7, 3),
        aKey: new KeyControlMethod(65, "x", -0.7, 3),
        sKey: new KeyControlMethod(83, "y", 0.7, 3),
        dKey: new KeyControlMethod(68, "x", 0.7, 3),
        qKey: new KeyControlMethod(81, "roll", 0.7, 3),
        eKey: new KeyControlMethod(69, "roll", -0.7, 3)
      };
      var enabledControls = ["scrollZoom", "touchView", "pinch"];
      if (opts.scrollZoom !== false) {
        controlMethods.scrollZoom = new ScrollZoomControlMethod(element);
      }
      var controlMethodGroups = {
        arrowKeys: ["leftArrowKey", "rightArrowKey", "upArrowKey", "downArrowKey"],
        plusMinusKeys: ["plusKey", "minusKey"],
        wasdKeys: ["wKey", "aKey", "sKey", "dKey"],
        qeKeys: ["qKey", "eKey"]
      };
      switch (opts.dragMode) {
        case "pinch":
          controlMethods.pinch = new DragControlMethod(element, "touch", { hammerEvent: "pinch" });
          break;
        case "pan":
          controlMethods.touchView = new DragControlMethod(element, "touch");
          controlMethods.pinch = new PinchZoomControlMethod(element, "touch");
          break;
        default:
          throw new Error("Unknown drag mode: " + opts.dragMode);
      }
      switch (opts.mouseViewMode) {
        case "drag":
          enabledControls.push("mouseViewDrag");
          break;
        case "qtvr":
          enabledControls.push("mouseViewQtvr");
          break;
        default:
          throw new Error("Unknown mouse view mode: " + opts.mouseViewMode);
      }
      for (var id in controlMethods) {
        var method = controlMethods[id];
        controls.registerMethod(id, method);
        if (enabledControls.indexOf(id) >= 0) {
          controls.enableMethod(id);
        }
      }
      for (var groupId in controlMethodGroups) {
        var methodGroup = controlMethodGroups[groupId];
        controls.addMethodGroup(groupId, methodGroup);
      }
      return controlMethods;
    }
    module.exports = registerDefaultControls;
  }
});

// node_modules/marzipano/src/util/tween.js
var require_tween = __commonJS({
  "node_modules/marzipano/src/util/tween.js"(exports, module) {
    "use strict";
    var now = require_now();
    function tween(duration, update, done) {
      var cancelled = false;
      var startTime = now();
      function runUpdate() {
        if (cancelled) {
          return;
        }
        var tweenVal = (now() - startTime) / duration;
        if (tweenVal < 1) {
          update(tweenVal);
          requestAnimationFrame(runUpdate);
        } else {
          update(1);
          done();
        }
      }
      update(0);
      requestAnimationFrame(runUpdate);
      return function cancel() {
        cancelled = true;
        done.apply(null, arguments);
      };
    }
    module.exports = tween;
  }
});

// node_modules/marzipano/src/Viewer.js
var require_Viewer = __commonJS({
  "node_modules/marzipano/src/Viewer.js"(exports, module) {
    "use strict";
    var eventEmitter = require_minimal_event_emitter();
    var RenderLoop = require_RenderLoop();
    var Controls = require_Controls();
    var Scene = require_Scene();
    var Timer = require_Timer();
    var WebGlStage = require_WebGl();
    var ControlCursor = require_ControlCursor();
    var HammerGestures = require_HammerGestures();
    var registerDefaultControls = require_registerDefaultControls();
    var registerDefaultRenderers = require_registerDefaultRenderers();
    var setOverflowHidden = require_dom().setOverflowHidden;
    var setAbsolute = require_dom().setAbsolute;
    var setFullSize = require_dom().setFullSize;
    var tween = require_tween();
    var noop = require_noop();
    var clearOwnProperties = require_clearOwnProperties();
    function Viewer(domElement, opts) {
      opts = opts || {};
      this._domElement = domElement;
      setOverflowHidden(domElement);
      this._stage = new WebGlStage(opts.stage);
      registerDefaultRenderers(this._stage);
      this._domElement.appendChild(this._stage.domElement());
      this._controlContainer = document.createElement("div");
      setAbsolute(this._controlContainer);
      setFullSize(this._controlContainer);
      domElement.appendChild(this._controlContainer);
      this._size = {};
      this.updateSize();
      this._updateSizeListener = this.updateSize.bind(this);
      window.addEventListener("resize", this._updateSizeListener);
      this._renderLoop = new RenderLoop(this._stage);
      this._controls = new Controls();
      this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);
      this._controls.attach(this._renderLoop);
      this._hammerManagerTouch = HammerGestures.get(this._controlContainer, "touch");
      this._hammerManagerMouse = HammerGestures.get(this._controlContainer, "mouse");
      this._dragCursor = new ControlCursor(this._controls, "mouseViewDrag", domElement, opts.cursors && opts.cursors.drag || {});
      this._renderLoop.start();
      this._scenes = [];
      this._currentScene = null;
      this._replacedScene = null;
      this._cancelCurrentTween = null;
      this._layerChangeHandler = this._updateSceneLayers.bind(this);
      this._viewChangeHandler = this.emit.bind(this, "viewChange");
      this._idleTimer = new Timer();
      this._idleTimer.start();
      this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);
      this.addEventListener("viewChange", this._resetIdleTimerHandler);
      this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);
      this._idleTimer.addEventListener("timeout", this._triggerIdleTimerHandler);
      this._stopMovementHandler = this.stopMovement.bind(this);
      this._controls.addEventListener("active", this._stopMovementHandler);
      this.addEventListener("sceneChange", this._stopMovementHandler);
      this._idleMovement = null;
    }
    eventEmitter(Viewer);
    Viewer.prototype.destroy = function() {
      window.removeEventListener("resize", this._updateSizeListener);
      if (this._currentScene) {
        this._removeSceneEventListeners(this._currentScene);
      }
      if (this._replacedScene) {
        this._removeSceneEventListeners(this._replacedScene);
      }
      this._dragCursor.destroy();
      for (var methodName in this._controlMethods) {
        this._controlMethods[methodName].destroy();
      }
      while (this._scenes.length) {
        this.destroyScene(this._scenes[0]);
      }
      this._domElement.removeChild(this._stage.domElement());
      this._stage.destroy();
      this._renderLoop.destroy();
      this._controls.destroy();
      this._controls = null;
      if (this._cancelCurrentTween) {
        this._cancelCurrentTween();
      }
      clearOwnProperties(this);
    };
    Viewer.prototype.updateSize = function() {
      var size = this._size;
      size.width = this._domElement.clientWidth;
      size.height = this._domElement.clientHeight;
      this._stage.setSize(size);
    };
    Viewer.prototype.stage = function() {
      return this._stage;
    };
    Viewer.prototype.renderLoop = function() {
      return this._renderLoop;
    };
    Viewer.prototype.controls = function() {
      return this._controls;
    };
    Viewer.prototype.domElement = function() {
      return this._domElement;
    };
    Viewer.prototype.createScene = function(opts) {
      opts = opts || {};
      var scene = this.createEmptyScene({ view: opts.view });
      scene.createLayer({
        source: opts.source,
        geometry: opts.geometry,
        pinFirstLevel: opts.pinFirstLevel,
        textureStoreOpts: opts.textureStoreOpts,
        layerOpts: opts.layerOpts
      });
      return scene;
    };
    Viewer.prototype.createEmptyScene = function(opts) {
      opts = opts || {};
      var scene = new Scene(this, opts.view);
      this._scenes.push(scene);
      return scene;
    };
    Viewer.prototype._updateSceneLayers = function() {
      var i;
      var layer;
      var stage = this._stage;
      var currentScene = this._currentScene;
      var replacedScene = this._replacedScene;
      var oldLayers = stage.listLayers();
      var newLayers = [];
      if (replacedScene) {
        newLayers = newLayers.concat(replacedScene.listLayers());
      }
      if (currentScene) {
        newLayers = newLayers.concat(currentScene.listLayers());
      }
      if (Math.abs(oldLayers.length - newLayers.length) !== 1) {
        throw new Error("Stage and scene out of sync");
      }
      if (newLayers.length < oldLayers.length) {
        for (i = 0; i < oldLayers.length; i++) {
          layer = oldLayers[i];
          if (newLayers.indexOf(layer) < 0) {
            this._removeLayerFromStage(layer);
            break;
          }
        }
      }
      if (newLayers.length > oldLayers.length) {
        for (i = 0; i < newLayers.length; i++) {
          layer = newLayers[i];
          if (oldLayers.indexOf(layer) < 0) {
            this._addLayerToStage(layer, i);
          }
        }
      }
    };
    Viewer.prototype._addLayerToStage = function(layer, i) {
      layer.pinFirstLevel();
      this._stage.addLayer(layer, i);
    };
    Viewer.prototype._removeLayerFromStage = function(layer) {
      this._stage.removeLayer(layer);
      layer.unpinFirstLevel();
      layer.textureStore().clearNotPinned();
    };
    Viewer.prototype._addSceneEventListeners = function(scene) {
      scene.addEventListener("layerChange", this._layerChangeHandler);
      scene.addEventListener("viewChange", this._viewChangeHandler);
    };
    Viewer.prototype._removeSceneEventListeners = function(scene) {
      scene.removeEventListener("layerChange", this._layerChangeHandler);
      scene.removeEventListener("viewChange", this._viewChangeHandler);
    };
    Viewer.prototype.destroyScene = function(scene) {
      var i = this._scenes.indexOf(scene);
      if (i < 0) {
        throw new Error("No such scene in viewer");
      }
      var j;
      var layers;
      if (this._currentScene === scene) {
        this._removeSceneEventListeners(scene);
        layers = scene.listLayers();
        for (j = 0; j < layers.length; j++) {
          this._removeLayerFromStage(layers[j]);
        }
        if (this._cancelCurrentTween) {
          this._cancelCurrentTween();
          this._cancelCurrentTween = null;
        }
        this._currentScene = null;
        this.emit("sceneChange");
      }
      if (this._replacedScene === scene) {
        this._removeSceneEventListeners(scene);
        layers = scene.listLayers();
        for (j = 0; j < layers.length; j++) {
          this._removeLayerFromStage(layers[j]);
        }
        this._replacedScene = null;
      }
      this._scenes.splice(i, 1);
      scene.destroy();
    };
    Viewer.prototype.destroyAllScenes = function() {
      while (this._scenes.length > 0) {
        this.destroyScene(this._scenes[0]);
      }
    };
    Viewer.prototype.hasScene = function(scene) {
      return this._scenes.indexOf(scene) >= 0;
    };
    Viewer.prototype.listScenes = function() {
      return [].concat(this._scenes);
    };
    Viewer.prototype.scene = function() {
      return this._currentScene;
    };
    Viewer.prototype.view = function() {
      var scene = this._currentScene;
      if (scene) {
        return scene.view();
      }
      return null;
    };
    Viewer.prototype.lookTo = function(params, opts, done) {
      var scene = this._currentScene;
      if (scene) {
        scene.lookTo(params, opts, done);
      }
    };
    Viewer.prototype.startMovement = function(fn, done) {
      var scene = this._currentScene;
      if (!scene) {
        return;
      }
      scene.startMovement(fn, done);
    };
    Viewer.prototype.stopMovement = function() {
      var scene = this._currentScene;
      if (!scene) {
        return;
      }
      scene.stopMovement();
    };
    Viewer.prototype.movement = function() {
      var scene = this._currentScene;
      if (!scene) {
        return;
      }
      return scene.movement();
    };
    Viewer.prototype.setIdleMovement = function(timeout, movement) {
      this._idleTimer.setDuration(timeout);
      this._idleMovement = movement;
    };
    Viewer.prototype.breakIdleMovement = function() {
      this.stopMovement();
      this._resetIdleTimer();
    };
    Viewer.prototype._resetIdleTimer = function() {
      this._idleTimer.start();
    };
    Viewer.prototype._triggerIdleTimer = function() {
      var idleMovement = this._idleMovement;
      if (!idleMovement) {
        return;
      }
      this.startMovement(idleMovement);
    };
    var defaultSwitchDuration = 1e3;
    function defaultTransitionUpdate(val, newScene, oldScene) {
      var layers = newScene.listLayers();
      layers.forEach(function(layer) {
        layer.mergeEffects({ opacity: val });
      });
      newScene._hotspotContainer.domElement().style.opacity = val;
    }
    Viewer.prototype.switchScene = function(newScene, opts, done) {
      var self2 = this;
      opts = opts || {};
      done = done || noop;
      var stage = this._stage;
      var oldScene = this._currentScene;
      if (oldScene === newScene) {
        done();
        return;
      }
      if (this._scenes.indexOf(newScene) < 0) {
        throw new Error("No such scene in viewer");
      }
      if (this._cancelCurrentTween) {
        this._cancelCurrentTween();
        this._cancelCurrentTween = null;
      }
      var oldSceneLayers = oldScene ? oldScene.listLayers() : [];
      var newSceneLayers = newScene.listLayers();
      var stageLayers = stage.listLayers();
      if (oldScene && (stageLayers.length !== oldSceneLayers.length || stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0])) {
        throw new Error("Stage not in sync with viewer");
      }
      var duration = opts.transitionDuration != null ? opts.transitionDuration : defaultSwitchDuration;
      var update = opts.transitionUpdate != null ? opts.transitionUpdate : defaultTransitionUpdate;
      for (var i = 0; i < newSceneLayers.length; i++) {
        this._addLayerToStage(newSceneLayers[i]);
      }
      function tweenUpdate(val) {
        update(val, newScene, oldScene);
      }
      function tweenDone() {
        if (self2._replacedScene) {
          self2._removeSceneEventListeners(self2._replacedScene);
          oldSceneLayers = self2._replacedScene.listLayers();
          for (var i2 = 0; i2 < oldSceneLayers.length; i2++) {
            self2._removeLayerFromStage(oldSceneLayers[i2]);
          }
          self2._replacedScene = null;
        }
        self2._cancelCurrentTween = null;
        done();
      }
      this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);
      this._currentScene = newScene;
      this._replacedScene = oldScene;
      this.emit("sceneChange");
      this.emit("viewChange");
      this._addSceneEventListeners(newScene);
    };
    module.exports = Viewer;
  }
});

// node_modules/marzipano/src/colorEffects.js
var require_colorEffects = __commonJS({
  "node_modules/marzipano/src/colorEffects.js"(exports, module) {
    "use strict";
    var vec4 = (init_esm(), __toCommonJS(esm_exports)).vec4;
    var mat4 = (init_esm(), __toCommonJS(esm_exports)).mat4;
    function identity7(resultArg) {
      var result = resultArg || {};
      result.colorOffset = result.colorOffset || vec4.create();
      result.colorMatrix = result.colorMatrix || mat4.create();
      return result;
    }
    function applyToPixel(pixel, effect, result) {
      vec4TransformMat4Transposed(result, pixel, effect.colorMatrix);
      vec4.add(result, result, effect.colorOffset);
    }
    function vec4TransformMat4Transposed(out, a, m) {
      var x = a[0], y = a[1], z = a[2], w = a[3];
      out[0] = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
      out[1] = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
      out[2] = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
      out[3] = m[12] * x + m[13] * y + m[14] * z + m[15] * w;
      return out;
    }
    var tmpPixel = vec4.create();
    function applyToImageData(imageData, effect) {
      var width = imageData.width;
      var height = imageData.height;
      var data = imageData.data;
      for (var i = 0; i < width * height; i++) {
        vec4.set(tmpPixel, data[i * 4 + 0] / 255, data[i * 4 + 1] / 255, data[i * 4 + 2] / 255, data[i * 4 + 3] / 255);
        applyToPixel(tmpPixel, effect, tmpPixel);
        data[i * 4 + 0] = tmpPixel[0] * 255;
        data[i * 4 + 1] = tmpPixel[1] * 255;
        data[i * 4 + 2] = tmpPixel[2] * 255;
        data[i * 4 + 3] = tmpPixel[3] * 255;
      }
    }
    module.exports = {
      identity: identity7,
      applyToPixel,
      applyToImageData
    };
  }
});

// node_modules/marzipano/src/autorotate.js
var require_autorotate = __commonJS({
  "node_modules/marzipano/src/autorotate.js"(exports, module) {
    "use strict";
    var defaults = require_defaults();
    var defaultSpeed = 0.1;
    var defaultAccel = 0.01;
    var defaultOptions = {
      yawSpeed: defaultSpeed,
      pitchSpeed: defaultSpeed,
      fovSpeed: defaultSpeed,
      yawAccel: defaultAccel,
      pitchAccel: defaultAccel,
      fovAccel: defaultAccel,
      targetPitch: 0,
      targetFov: null
    };
    function autorotate(opts) {
      opts = defaults(opts || {}, defaultOptions);
      var yawSpeed = opts.yawSpeed;
      var pitchSpeed = opts.pitchSpeed;
      var fovSpeed = opts.fovSpeed;
      var yawAccel = opts.yawAccel;
      var pitchAccel = opts.pitchAccel;
      var fovAccel = opts.fovAccel;
      var targetPitch = opts.targetPitch;
      var targetFov = opts.targetFov;
      return function start() {
        var lastTime = 0;
        var lastYawSpeed = 0;
        var lastPitchSpeed = 0;
        var lastFovSpeed = 0;
        var currentYawSpeed = 0;
        var currentPitchSpeed = 0;
        var currentFovSpeed = 0;
        var timeDelta;
        var yawDelta;
        var pitchDelta;
        var fovDelta;
        return function step(params, currentTime) {
          timeDelta = (currentTime - lastTime) / 1e3;
          currentYawSpeed = Math.min(lastYawSpeed + timeDelta * yawAccel, yawSpeed);
          yawDelta = currentYawSpeed * timeDelta;
          params.yaw = params.yaw + yawDelta;
          if (targetPitch != null && params.pitch !== targetPitch) {
            var pitchThresh = 0.5 * lastPitchSpeed * lastPitchSpeed / pitchAccel;
            if (Math.abs(targetPitch - params.pitch) > pitchThresh) {
              currentPitchSpeed = Math.min(lastPitchSpeed + timeDelta * pitchAccel, pitchSpeed);
            } else {
              currentPitchSpeed = Math.max(lastPitchSpeed - timeDelta * pitchAccel, 0);
            }
            pitchDelta = currentPitchSpeed * timeDelta;
            if (targetPitch < params.pitch) {
              params.pitch = Math.max(targetPitch, params.pitch - pitchDelta);
            }
            if (targetPitch > params.pitch) {
              params.pitch = Math.min(targetPitch, params.pitch + pitchDelta);
            }
          }
          if (targetFov != null && params.fov !== targetPitch) {
            var fovThresh = 0.5 * lastFovSpeed * lastFovSpeed / fovAccel;
            if (Math.abs(targetFov - params.fov) > fovThresh) {
              currentFovSpeed = Math.min(lastFovSpeed + timeDelta * fovAccel, fovSpeed);
            } else {
              currentFovSpeed = Math.max(lastFovSpeed - timeDelta * fovAccel, 0);
            }
            fovDelta = currentFovSpeed * timeDelta;
            if (targetFov < params.fov) {
              params.fov = Math.max(targetFov, params.fov - fovDelta);
            }
            if (targetFov > params.fov) {
              params.fov = Math.min(targetFov, params.fov + fovDelta);
            }
          }
          lastTime = currentTime;
          lastYawSpeed = currentYawSpeed;
          lastPitchSpeed = currentPitchSpeed;
          lastFovSpeed = currentFovSpeed;
          return params;
        };
      };
    }
    module.exports = autorotate;
  }
});

// node_modules/marzipano/src/util/defer.js
var require_defer = __commonJS({
  "node_modules/marzipano/src/util/defer.js"(exports, module) {
    "use strict";
    function defer(fn, args) {
      function deferred() {
        if (args && args.length > 0) {
          fn.apply(null, args);
        } else {
          fn();
        }
      }
      setTimeout(deferred, 0);
    }
    module.exports = defer;
  }
});

// node_modules/marzipano/src/util/degToRad.js
var require_degToRad = __commonJS({
  "node_modules/marzipano/src/util/degToRad.js"(exports, module) {
    "use strict";
    function degToRad(deg) {
      return deg * Math.PI / 180;
    }
    module.exports = degToRad;
  }
});

// node_modules/marzipano/src/util/radToDeg.js
var require_radToDeg = __commonJS({
  "node_modules/marzipano/src/util/radToDeg.js"(exports, module) {
    "use strict";
    function radToDeg(rad) {
      return rad * 180 / Math.PI;
    }
    module.exports = radToDeg;
  }
});

// node_modules/marzipano/src/index.js
var require_src = __commonJS({
  "node_modules/marzipano/src/index.js"(exports, module) {
    module.exports = {
      // Stages.
      WebGlStage: require_WebGl(),
      // Renderers.
      WebGlCubeRenderer: require_WebGlCube(),
      WebGlFlatRenderer: require_WebGlFlat(),
      WebGlEquirectRenderer: require_WebGlEquirect(),
      registerDefaultRenderers: require_registerDefaultRenderers(),
      // Geometries.
      CubeGeometry: require_Cube(),
      FlatGeometry: require_Flat(),
      EquirectGeometry: require_Equirect(),
      // Views.
      RectilinearView: require_Rectilinear(),
      FlatView: require_Flat2(),
      // Sources.
      ImageUrlSource: require_ImageUrl(),
      SingleAssetSource: require_SingleAsset(),
      // Assets.
      StaticAsset: require_Static(),
      DynamicAsset: require_Dynamic(),
      // Texture store.
      TextureStore: require_TextureStore(),
      // Layer.
      Layer: require_Layer(),
      // Render loop.
      RenderLoop: require_RenderLoop(),
      // Controls.
      KeyControlMethod: require_Key(),
      DragControlMethod: require_Drag(),
      QtvrControlMethod: require_Qtvr(),
      ScrollZoomControlMethod: require_ScrollZoom(),
      PinchZoomControlMethod: require_PinchZoom(),
      VelocityControlMethod: require_Velocity(),
      ElementPressControlMethod: require_ElementPress(),
      Controls: require_Controls(),
      Dynamics: require_Dynamics(),
      // High-level API.
      Viewer: require_Viewer(),
      Scene: require_Scene(),
      // Hotspots.
      Hotspot: require_Hotspot(),
      HotspotContainer: require_HotspotContainer(),
      // Effects.
      colorEffects: require_colorEffects(),
      // Miscellaneous functions.
      registerDefaultControls: require_registerDefaultControls(),
      autorotate: require_autorotate(),
      // Utility functions.
      util: {
        async: require_async(),
        cancelize: require_cancelize(),
        chain: require_chain(),
        clamp: require_clamp(),
        clearOwnProperties: require_clearOwnProperties(),
        cmp: require_cmp(),
        compose: require_compose(),
        convertFov: require_convertFov(),
        decimal: require_decimal(),
        defaults: require_defaults(),
        defer: require_defer(),
        degToRad: require_degToRad(),
        delay: require_delay(),
        dom: require_dom(),
        extend: require_extend(),
        hash: require_hash(),
        inherits: require_inherits(),
        mod: require_mod(),
        noop: require_noop(),
        now: require_now(),
        once: require_once(),
        pixelRatio: require_pixelRatio(),
        radToDeg: require_radToDeg(),
        real: require_real(),
        retry: require_retry(),
        tween: require_tween(),
        type: require_type()
      },
      // Expose dependencies for clients to use.
      dependencies: {
        bowser: require_bowser(),
        glMatrix: (init_esm(), __toCommonJS(esm_exports)),
        eventEmitter: require_minimal_event_emitter(),
        hammerjs: require_hammer()
      }
    };
  }
});
export default require_src();
/*! Bundled license information:

bowser/src/bowser.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/ded/bowser
   * MIT License | (c) Dustin Diaz 2015
   *)

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.4 - 2014-09-28
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2014 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=marzipano.js.map
